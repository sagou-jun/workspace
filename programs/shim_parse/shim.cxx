// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "shim.hxx"

// ComponentSet
// 

const ComponentSet::ComponentSet1_sequence& ComponentSet::
ComponentSet1 () const
{
  return this->ComponentSet1_;
}

ComponentSet::ComponentSet1_sequence& ComponentSet::
ComponentSet1 ()
{
  return this->ComponentSet1_;
}

void ComponentSet::
ComponentSet1 (const ComponentSet1_sequence& s)
{
  this->ComponentSet1_ = s;
}

const ComponentSet::SlaveComponent_sequence& ComponentSet::
SlaveComponent () const
{
  return this->SlaveComponent_;
}

ComponentSet::SlaveComponent_sequence& ComponentSet::
SlaveComponent ()
{
  return this->SlaveComponent_;
}

void ComponentSet::
SlaveComponent (const SlaveComponent_sequence& s)
{
  this->SlaveComponent_ = s;
}

const ComponentSet::MasterComponent_sequence& ComponentSet::
MasterComponent () const
{
  return this->MasterComponent_;
}

ComponentSet::MasterComponent_sequence& ComponentSet::
MasterComponent ()
{
  return this->MasterComponent_;
}

void ComponentSet::
MasterComponent (const MasterComponent_sequence& s)
{
  this->MasterComponent_ = s;
}

const ComponentSet::Cache_sequence& ComponentSet::
Cache () const
{
  return this->Cache_;
}

ComponentSet::Cache_sequence& ComponentSet::
Cache ()
{
  return this->Cache_;
}

void ComponentSet::
Cache (const Cache_sequence& s)
{
  this->Cache_ = s;
}

const ComponentSet::name_type& ComponentSet::
name () const
{
  return this->name_.get ();
}

ComponentSet::name_type& ComponentSet::
name ()
{
  return this->name_.get ();
}

void ComponentSet::
name (const name_type& x)
{
  this->name_.set (x);
}

void ComponentSet::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// SlaveComponent
// 

const SlaveComponent::name_type& SlaveComponent::
name () const
{
  return this->name_.get ();
}

SlaveComponent::name_type& SlaveComponent::
name ()
{
  return this->name_.get ();
}

void SlaveComponent::
name (const name_type& x)
{
  this->name_.set (x);
}

void SlaveComponent::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const SlaveComponent::id_type& SlaveComponent::
id () const
{
  return this->id_.get ();
}

SlaveComponent::id_type& SlaveComponent::
id ()
{
  return this->id_.get ();
}

void SlaveComponent::
id (const id_type& x)
{
  this->id_.set (x);
}

void SlaveComponent::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const SlaveComponent::size_type& SlaveComponent::
size () const
{
  return this->size_.get ();
}

SlaveComponent::size_type& SlaveComponent::
size ()
{
  return this->size_.get ();
}

void SlaveComponent::
size (const size_type& x)
{
  this->size_.set (x);
}

const SlaveComponent::sizeUnit_type& SlaveComponent::
sizeUnit () const
{
  return this->sizeUnit_.get ();
}

SlaveComponent::sizeUnit_type& SlaveComponent::
sizeUnit ()
{
  return this->sizeUnit_.get ();
}

void SlaveComponent::
sizeUnit (const sizeUnit_type& x)
{
  this->sizeUnit_.set (x);
}

void SlaveComponent::
sizeUnit (::std::auto_ptr< sizeUnit_type > x)
{
  this->sizeUnit_.set (x);
}

const SlaveComponent::rwType_type& SlaveComponent::
rwType () const
{
  return this->rwType_.get ();
}

SlaveComponent::rwType_type& SlaveComponent::
rwType ()
{
  return this->rwType_.get ();
}

void SlaveComponent::
rwType (const rwType_type& x)
{
  this->rwType_.set (x);
}

void SlaveComponent::
rwType (::std::auto_ptr< rwType_type > x)
{
  this->rwType_.set (x);
}


// MasterComponent
// 

const MasterComponent::CommonInstructionSet_optional& MasterComponent::
CommonInstructionSet () const
{
  return this->CommonInstructionSet_;
}

MasterComponent::CommonInstructionSet_optional& MasterComponent::
CommonInstructionSet ()
{
  return this->CommonInstructionSet_;
}

void MasterComponent::
CommonInstructionSet (const CommonInstructionSet_type& x)
{
  this->CommonInstructionSet_.set (x);
}

void MasterComponent::
CommonInstructionSet (const CommonInstructionSet_optional& x)
{
  this->CommonInstructionSet_ = x;
}

void MasterComponent::
CommonInstructionSet (::std::auto_ptr< CommonInstructionSet_type > x)
{
  this->CommonInstructionSet_.set (x);
}

const MasterComponent::Cache_sequence& MasterComponent::
Cache () const
{
  return this->Cache_;
}

MasterComponent::Cache_sequence& MasterComponent::
Cache ()
{
  return this->Cache_;
}

void MasterComponent::
Cache (const Cache_sequence& s)
{
  this->Cache_ = s;
}

const MasterComponent::ClockFrequency_optional& MasterComponent::
ClockFrequency () const
{
  return this->ClockFrequency_;
}

MasterComponent::ClockFrequency_optional& MasterComponent::
ClockFrequency ()
{
  return this->ClockFrequency_;
}

void MasterComponent::
ClockFrequency (const ClockFrequency_type& x)
{
  this->ClockFrequency_.set (x);
}

void MasterComponent::
ClockFrequency (const ClockFrequency_optional& x)
{
  this->ClockFrequency_ = x;
}

void MasterComponent::
ClockFrequency (::std::auto_ptr< ClockFrequency_type > x)
{
  this->ClockFrequency_.set (x);
}

const MasterComponent::AccessTypeSet_type& MasterComponent::
AccessTypeSet () const
{
  return this->AccessTypeSet_.get ();
}

MasterComponent::AccessTypeSet_type& MasterComponent::
AccessTypeSet ()
{
  return this->AccessTypeSet_.get ();
}

void MasterComponent::
AccessTypeSet (const AccessTypeSet_type& x)
{
  this->AccessTypeSet_.set (x);
}

void MasterComponent::
AccessTypeSet (::std::auto_ptr< AccessTypeSet_type > x)
{
  this->AccessTypeSet_.set (x);
}

const MasterComponent::name_type& MasterComponent::
name () const
{
  return this->name_.get ();
}

MasterComponent::name_type& MasterComponent::
name ()
{
  return this->name_.get ();
}

void MasterComponent::
name (const name_type& x)
{
  this->name_.set (x);
}

void MasterComponent::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const MasterComponent::id_type& MasterComponent::
id () const
{
  return this->id_.get ();
}

MasterComponent::id_type& MasterComponent::
id ()
{
  return this->id_.get ();
}

void MasterComponent::
id (const id_type& x)
{
  this->id_.set (x);
}

void MasterComponent::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const MasterComponent::masterType_type& MasterComponent::
masterType () const
{
  return this->masterType_.get ();
}

MasterComponent::masterType_type& MasterComponent::
masterType ()
{
  return this->masterType_.get ();
}

void MasterComponent::
masterType (const masterType_type& x)
{
  this->masterType_.set (x);
}

void MasterComponent::
masterType (::std::auto_ptr< masterType_type > x)
{
  this->masterType_.set (x);
}

const MasterComponent::arch_type& MasterComponent::
arch () const
{
  return this->arch_.get ();
}

MasterComponent::arch_type& MasterComponent::
arch ()
{
  return this->arch_.get ();
}

void MasterComponent::
arch (const arch_type& x)
{
  this->arch_.set (x);
}

void MasterComponent::
arch (::std::auto_ptr< arch_type > x)
{
  this->arch_.set (x);
}

const MasterComponent::archOption_optional& MasterComponent::
archOption () const
{
  return this->archOption_;
}

MasterComponent::archOption_optional& MasterComponent::
archOption ()
{
  return this->archOption_;
}

void MasterComponent::
archOption (const archOption_type& x)
{
  this->archOption_.set (x);
}

void MasterComponent::
archOption (const archOption_optional& x)
{
  this->archOption_ = x;
}

void MasterComponent::
archOption (::std::auto_ptr< archOption_type > x)
{
  this->archOption_.set (x);
}

const MasterComponent::pid_optional& MasterComponent::
pid () const
{
  return this->pid_;
}

MasterComponent::pid_optional& MasterComponent::
pid ()
{
  return this->pid_;
}

void MasterComponent::
pid (const pid_type& x)
{
  this->pid_.set (x);
}

void MasterComponent::
pid (const pid_optional& x)
{
  this->pid_ = x;
}

void MasterComponent::
pid (::std::auto_ptr< pid_type > x)
{
  this->pid_.set (x);
}

const MasterComponent::nThread_optional& MasterComponent::
nThread () const
{
  return this->nThread_;
}

MasterComponent::nThread_optional& MasterComponent::
nThread ()
{
  return this->nThread_;
}

void MasterComponent::
nThread (const nThread_type& x)
{
  this->nThread_.set (x);
}

void MasterComponent::
nThread (const nThread_optional& x)
{
  this->nThread_ = x;
}

const MasterComponent::endian_optional& MasterComponent::
endian () const
{
  return this->endian_;
}

MasterComponent::endian_optional& MasterComponent::
endian ()
{
  return this->endian_;
}

void MasterComponent::
endian (const endian_type& x)
{
  this->endian_.set (x);
}

void MasterComponent::
endian (const endian_optional& x)
{
  this->endian_ = x;
}

void MasterComponent::
endian (::std::auto_ptr< endian_type > x)
{
  this->endian_.set (x);
}


// RWType
// 

RWType::
RWType (value v)
: ::xml_schema::string (_xsd_RWType_literals_[v])
{
}

RWType::
RWType (const char* v)
: ::xml_schema::string (v)
{
}

RWType::
RWType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RWType::
RWType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RWType::
RWType (const RWType& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RWType& RWType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RWType_literals_[v]);

  return *this;
}


// AddressSpaceSet
// 

const AddressSpaceSet::AddressSpace_sequence& AddressSpaceSet::
AddressSpace () const
{
  return this->AddressSpace_;
}

AddressSpaceSet::AddressSpace_sequence& AddressSpaceSet::
AddressSpace ()
{
  return this->AddressSpace_;
}

void AddressSpaceSet::
AddressSpace (const AddressSpace_sequence& s)
{
  this->AddressSpace_ = s;
}


// AddressSpace
// 

const AddressSpace::SubSpace_sequence& AddressSpace::
SubSpace () const
{
  return this->SubSpace_;
}

AddressSpace::SubSpace_sequence& AddressSpace::
SubSpace ()
{
  return this->SubSpace_;
}

void AddressSpace::
SubSpace (const SubSpace_sequence& s)
{
  this->SubSpace_ = s;
}

const AddressSpace::name_type& AddressSpace::
name () const
{
  return this->name_.get ();
}

AddressSpace::name_type& AddressSpace::
name ()
{
  return this->name_.get ();
}

void AddressSpace::
name (const name_type& x)
{
  this->name_.set (x);
}

void AddressSpace::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const AddressSpace::id_type& AddressSpace::
id () const
{
  return this->id_.get ();
}

AddressSpace::id_type& AddressSpace::
id ()
{
  return this->id_.get ();
}

void AddressSpace::
id (const id_type& x)
{
  this->id_.set (x);
}

void AddressSpace::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}


// SubSpace
// 

const SubSpace::MemoryConsistencyModel_sequence& SubSpace::
MemoryConsistencyModel () const
{
  return this->MemoryConsistencyModel_;
}

SubSpace::MemoryConsistencyModel_sequence& SubSpace::
MemoryConsistencyModel ()
{
  return this->MemoryConsistencyModel_;
}

void SubSpace::
MemoryConsistencyModel (const MemoryConsistencyModel_sequence& s)
{
  this->MemoryConsistencyModel_ = s;
}

const SubSpace::MasterSlaveBindingSet_optional& SubSpace::
MasterSlaveBindingSet () const
{
  return this->MasterSlaveBindingSet_;
}

SubSpace::MasterSlaveBindingSet_optional& SubSpace::
MasterSlaveBindingSet ()
{
  return this->MasterSlaveBindingSet_;
}

void SubSpace::
MasterSlaveBindingSet (const MasterSlaveBindingSet_type& x)
{
  this->MasterSlaveBindingSet_.set (x);
}

void SubSpace::
MasterSlaveBindingSet (const MasterSlaveBindingSet_optional& x)
{
  this->MasterSlaveBindingSet_ = x;
}

void SubSpace::
MasterSlaveBindingSet (::std::auto_ptr< MasterSlaveBindingSet_type > x)
{
  this->MasterSlaveBindingSet_.set (x);
}

const SubSpace::name_type& SubSpace::
name () const
{
  return this->name_.get ();
}

SubSpace::name_type& SubSpace::
name ()
{
  return this->name_.get ();
}

void SubSpace::
name (const name_type& x)
{
  this->name_.set (x);
}

void SubSpace::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const SubSpace::id_type& SubSpace::
id () const
{
  return this->id_.get ();
}

SubSpace::id_type& SubSpace::
id ()
{
  return this->id_.get ();
}

void SubSpace::
id (const id_type& x)
{
  this->id_.set (x);
}

void SubSpace::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const SubSpace::start_type& SubSpace::
start () const
{
  return this->start_.get ();
}

SubSpace::start_type& SubSpace::
start ()
{
  return this->start_.get ();
}

void SubSpace::
start (const start_type& x)
{
  this->start_.set (x);
}

const SubSpace::end_type& SubSpace::
end () const
{
  return this->end_.get ();
}

SubSpace::end_type& SubSpace::
end ()
{
  return this->end_.get ();
}

void SubSpace::
end (const end_type& x)
{
  this->end_.set (x);
}

const SubSpace::endian_optional& SubSpace::
endian () const
{
  return this->endian_;
}

SubSpace::endian_optional& SubSpace::
endian ()
{
  return this->endian_;
}

void SubSpace::
endian (const endian_type& x)
{
  this->endian_.set (x);
}

void SubSpace::
endian (const endian_optional& x)
{
  this->endian_ = x;
}

void SubSpace::
endian (::std::auto_ptr< endian_type > x)
{
  this->endian_.set (x);
}


// MasterType
// 

MasterType::
MasterType (value v)
: ::xml_schema::string (_xsd_MasterType_literals_[v])
{
}

MasterType::
MasterType (const char* v)
: ::xml_schema::string (v)
{
}

MasterType::
MasterType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

MasterType::
MasterType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

MasterType::
MasterType (const MasterType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

MasterType& MasterType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_MasterType_literals_[v]);

  return *this;
}


// Instruction
// 

const Instruction::Performance_type& Instruction::
Performance () const
{
  return this->Performance_.get ();
}

Instruction::Performance_type& Instruction::
Performance ()
{
  return this->Performance_.get ();
}

void Instruction::
Performance (const Performance_type& x)
{
  this->Performance_.set (x);
}

void Instruction::
Performance (::std::auto_ptr< Performance_type > x)
{
  this->Performance_.set (x);
}

const Instruction::name_type& Instruction::
name () const
{
  return this->name_.get ();
}

Instruction::name_type& Instruction::
name ()
{
  return this->name_.get ();
}

void Instruction::
name (const name_type& x)
{
  this->name_.set (x);
}

void Instruction::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// AbstractCommunication
// 

const AbstractCommunication::ConnectionSet_optional& AbstractCommunication::
ConnectionSet () const
{
  return this->ConnectionSet_;
}

AbstractCommunication::ConnectionSet_optional& AbstractCommunication::
ConnectionSet ()
{
  return this->ConnectionSet_;
}

void AbstractCommunication::
ConnectionSet (const ConnectionSet_type& x)
{
  this->ConnectionSet_.set (x);
}

void AbstractCommunication::
ConnectionSet (const ConnectionSet_optional& x)
{
  this->ConnectionSet_ = x;
}

void AbstractCommunication::
ConnectionSet (::std::auto_ptr< ConnectionSet_type > x)
{
  this->ConnectionSet_.set (x);
}

const AbstractCommunication::name_type& AbstractCommunication::
name () const
{
  return this->name_.get ();
}

AbstractCommunication::name_type& AbstractCommunication::
name ()
{
  return this->name_.get ();
}

void AbstractCommunication::
name (const name_type& x)
{
  this->name_.set (x);
}

void AbstractCommunication::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// InterruptCommunication
// 


// AbstractPerformance
// 

const AbstractPerformance::best_optional& AbstractPerformance::
best () const
{
  return this->best_;
}

AbstractPerformance::best_optional& AbstractPerformance::
best ()
{
  return this->best_;
}

void AbstractPerformance::
best (const best_type& x)
{
  this->best_.set (x);
}

void AbstractPerformance::
best (const best_optional& x)
{
  this->best_ = x;
}

const AbstractPerformance::typical_type& AbstractPerformance::
typical () const
{
  return this->typical_.get ();
}

AbstractPerformance::typical_type& AbstractPerformance::
typical ()
{
  return this->typical_.get ();
}

void AbstractPerformance::
typical (const typical_type& x)
{
  this->typical_.set (x);
}

const AbstractPerformance::worst_optional& AbstractPerformance::
worst () const
{
  return this->worst_;
}

AbstractPerformance::worst_optional& AbstractPerformance::
worst ()
{
  return this->worst_;
}

void AbstractPerformance::
worst (const worst_type& x)
{
  this->worst_.set (x);
}

void AbstractPerformance::
worst (const worst_optional& x)
{
  this->worst_ = x;
}


// Latency
// 


// Pitch
// 


// MasterSlaveBinding
// 

const MasterSlaveBinding::Accessor_sequence& MasterSlaveBinding::
Accessor () const
{
  return this->Accessor_;
}

MasterSlaveBinding::Accessor_sequence& MasterSlaveBinding::
Accessor ()
{
  return this->Accessor_;
}

void MasterSlaveBinding::
Accessor (const Accessor_sequence& s)
{
  this->Accessor_ = s;
}

const MasterSlaveBinding::slaveComponentRef_type& MasterSlaveBinding::
slaveComponentRef () const
{
  return this->slaveComponentRef_.get ();
}

MasterSlaveBinding::slaveComponentRef_type& MasterSlaveBinding::
slaveComponentRef ()
{
  return this->slaveComponentRef_.get ();
}

void MasterSlaveBinding::
slaveComponentRef (const slaveComponentRef_type& x)
{
  this->slaveComponentRef_.set (x);
}

void MasterSlaveBinding::
slaveComponentRef (::std::auto_ptr< slaveComponentRef_type > x)
{
  this->slaveComponentRef_.set (x);
}


// CommunicationSet
// 

const CommunicationSet::SharedRegisterCommunication_sequence& CommunicationSet::
SharedRegisterCommunication () const
{
  return this->SharedRegisterCommunication_;
}

CommunicationSet::SharedRegisterCommunication_sequence& CommunicationSet::
SharedRegisterCommunication ()
{
  return this->SharedRegisterCommunication_;
}

void CommunicationSet::
SharedRegisterCommunication (const SharedRegisterCommunication_sequence& s)
{
  this->SharedRegisterCommunication_ = s;
}

const CommunicationSet::SharedMemoryCommunication_sequence& CommunicationSet::
SharedMemoryCommunication () const
{
  return this->SharedMemoryCommunication_;
}

CommunicationSet::SharedMemoryCommunication_sequence& CommunicationSet::
SharedMemoryCommunication ()
{
  return this->SharedMemoryCommunication_;
}

void CommunicationSet::
SharedMemoryCommunication (const SharedMemoryCommunication_sequence& s)
{
  this->SharedMemoryCommunication_ = s;
}

const CommunicationSet::EventCommunication_sequence& CommunicationSet::
EventCommunication () const
{
  return this->EventCommunication_;
}

CommunicationSet::EventCommunication_sequence& CommunicationSet::
EventCommunication ()
{
  return this->EventCommunication_;
}

void CommunicationSet::
EventCommunication (const EventCommunication_sequence& s)
{
  this->EventCommunication_ = s;
}

const CommunicationSet::FIFOCommunication_sequence& CommunicationSet::
FIFOCommunication () const
{
  return this->FIFOCommunication_;
}

CommunicationSet::FIFOCommunication_sequence& CommunicationSet::
FIFOCommunication ()
{
  return this->FIFOCommunication_;
}

void CommunicationSet::
FIFOCommunication (const FIFOCommunication_sequence& s)
{
  this->FIFOCommunication_ = s;
}

const CommunicationSet::InterruptCommunication_sequence& CommunicationSet::
InterruptCommunication () const
{
  return this->InterruptCommunication_;
}

CommunicationSet::InterruptCommunication_sequence& CommunicationSet::
InterruptCommunication ()
{
  return this->InterruptCommunication_;
}

void CommunicationSet::
InterruptCommunication (const InterruptCommunication_sequence& s)
{
  this->InterruptCommunication_ = s;
}


// Connection
// 

const Connection::Performance_sequence& Connection::
Performance () const
{
  return this->Performance_;
}

Connection::Performance_sequence& Connection::
Performance ()
{
  return this->Performance_;
}

void Connection::
Performance (const Performance_sequence& s)
{
  this->Performance_ = s;
}

const Connection::from_type& Connection::
from () const
{
  return this->from_.get ();
}

Connection::from_type& Connection::
from ()
{
  return this->from_.get ();
}

void Connection::
from (const from_type& x)
{
  this->from_.set (x);
}

void Connection::
from (::std::auto_ptr< from_type > x)
{
  this->from_.set (x);
}

const Connection::to_type& Connection::
to () const
{
  return this->to_.get ();
}

Connection::to_type& Connection::
to ()
{
  return this->to_.get ();
}

void Connection::
to (const to_type& x)
{
  this->to_.set (x);
}

void Connection::
to (::std::auto_ptr< to_type > x)
{
  this->to_.set (x);
}


// PerformanceSet
// 

const PerformanceSet::Performance_sequence& PerformanceSet::
Performance () const
{
  return this->Performance_;
}

PerformanceSet::Performance_sequence& PerformanceSet::
Performance ()
{
  return this->Performance_;
}

void PerformanceSet::
Performance (const Performance_sequence& s)
{
  this->Performance_ = s;
}


// FIFOCommunication
// 

const FIFOCommunication::dataSize_type& FIFOCommunication::
dataSize () const
{
  return this->dataSize_.get ();
}

FIFOCommunication::dataSize_type& FIFOCommunication::
dataSize ()
{
  return this->dataSize_.get ();
}

void FIFOCommunication::
dataSize (const dataSize_type& x)
{
  this->dataSize_.set (x);
}

const FIFOCommunication::dataSizeUnit_optional& FIFOCommunication::
dataSizeUnit () const
{
  return this->dataSizeUnit_;
}

FIFOCommunication::dataSizeUnit_optional& FIFOCommunication::
dataSizeUnit ()
{
  return this->dataSizeUnit_;
}

void FIFOCommunication::
dataSizeUnit (const dataSizeUnit_type& x)
{
  this->dataSizeUnit_.set (x);
}

void FIFOCommunication::
dataSizeUnit (const dataSizeUnit_optional& x)
{
  this->dataSizeUnit_ = x;
}

void FIFOCommunication::
dataSizeUnit (::std::auto_ptr< dataSizeUnit_type > x)
{
  this->dataSizeUnit_.set (x);
}

const FIFOCommunication::queueSize_type& FIFOCommunication::
queueSize () const
{
  return this->queueSize_.get ();
}

FIFOCommunication::queueSize_type& FIFOCommunication::
queueSize ()
{
  return this->queueSize_.get ();
}

void FIFOCommunication::
queueSize (const queueSize_type& x)
{
  this->queueSize_.set (x);
}


// CommonInstructionSet
// 

const CommonInstructionSet::Instruction_sequence& CommonInstructionSet::
Instruction () const
{
  return this->Instruction_;
}

CommonInstructionSet::Instruction_sequence& CommonInstructionSet::
Instruction ()
{
  return this->Instruction_;
}

void CommonInstructionSet::
Instruction (const Instruction_sequence& s)
{
  this->Instruction_ = s;
}

const CommonInstructionSet::name_type& CommonInstructionSet::
name () const
{
  return this->name_.get ();
}

CommonInstructionSet::name_type& CommonInstructionSet::
name ()
{
  return this->name_.get ();
}

void CommonInstructionSet::
name (const name_type& x)
{
  this->name_.set (x);
}

void CommonInstructionSet::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// Cache
// 

const Cache::cacheRef_sequence& Cache::
cacheRef () const
{
  return this->cacheRef_;
}

Cache::cacheRef_sequence& Cache::
cacheRef ()
{
  return this->cacheRef_;
}

void Cache::
cacheRef (const cacheRef_sequence& s)
{
  this->cacheRef_ = s;
}

const Cache::name_type& Cache::
name () const
{
  return this->name_.get ();
}

Cache::name_type& Cache::
name ()
{
  return this->name_.get ();
}

void Cache::
name (const name_type& x)
{
  this->name_.set (x);
}

void Cache::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const Cache::id_type& Cache::
id () const
{
  return this->id_.get ();
}

Cache::id_type& Cache::
id ()
{
  return this->id_.get ();
}

void Cache::
id (const id_type& x)
{
  this->id_.set (x);
}

void Cache::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const Cache::cacheType_type& Cache::
cacheType () const
{
  return this->cacheType_.get ();
}

Cache::cacheType_type& Cache::
cacheType ()
{
  return this->cacheType_.get ();
}

void Cache::
cacheType (const cacheType_type& x)
{
  this->cacheType_.set (x);
}

void Cache::
cacheType (::std::auto_ptr< cacheType_type > x)
{
  this->cacheType_.set (x);
}

const Cache::cacheCoherency_type& Cache::
cacheCoherency () const
{
  return this->cacheCoherency_.get ();
}

Cache::cacheCoherency_type& Cache::
cacheCoherency ()
{
  return this->cacheCoherency_.get ();
}

void Cache::
cacheCoherency (const cacheCoherency_type& x)
{
  this->cacheCoherency_.set (x);
}

void Cache::
cacheCoherency (::std::auto_ptr< cacheCoherency_type > x)
{
  this->cacheCoherency_.set (x);
}

const Cache::size_type& Cache::
size () const
{
  return this->size_.get ();
}

Cache::size_type& Cache::
size ()
{
  return this->size_.get ();
}

void Cache::
size (const size_type& x)
{
  this->size_.set (x);
}

const Cache::sizeUnit_type& Cache::
sizeUnit () const
{
  return this->sizeUnit_.get ();
}

Cache::sizeUnit_type& Cache::
sizeUnit ()
{
  return this->sizeUnit_.get ();
}

void Cache::
sizeUnit (const sizeUnit_type& x)
{
  this->sizeUnit_.set (x);
}

void Cache::
sizeUnit (::std::auto_ptr< sizeUnit_type > x)
{
  this->sizeUnit_.set (x);
}

const Cache::nWay_optional& Cache::
nWay () const
{
  return this->nWay_;
}

Cache::nWay_optional& Cache::
nWay ()
{
  return this->nWay_;
}

void Cache::
nWay (const nWay_type& x)
{
  this->nWay_.set (x);
}

void Cache::
nWay (const nWay_optional& x)
{
  this->nWay_ = x;
}

const Cache::lineSize_optional& Cache::
lineSize () const
{
  return this->lineSize_;
}

Cache::lineSize_optional& Cache::
lineSize ()
{
  return this->lineSize_;
}

void Cache::
lineSize (const lineSize_type& x)
{
  this->lineSize_.set (x);
}

void Cache::
lineSize (const lineSize_optional& x)
{
  this->lineSize_ = x;
}

const Cache::lockDownType_optional& Cache::
lockDownType () const
{
  return this->lockDownType_;
}

Cache::lockDownType_optional& Cache::
lockDownType ()
{
  return this->lockDownType_;
}

void Cache::
lockDownType (const lockDownType_type& x)
{
  this->lockDownType_.set (x);
}

void Cache::
lockDownType (const lockDownType_optional& x)
{
  this->lockDownType_ = x;
}

void Cache::
lockDownType (::std::auto_ptr< lockDownType_type > x)
{
  this->lockDownType_.set (x);
}


// SystemConfiguration
// 

const SystemConfiguration::ComponentSet_type& SystemConfiguration::
ComponentSet () const
{
  return this->ComponentSet_.get ();
}

SystemConfiguration::ComponentSet_type& SystemConfiguration::
ComponentSet ()
{
  return this->ComponentSet_.get ();
}

void SystemConfiguration::
ComponentSet (const ComponentSet_type& x)
{
  this->ComponentSet_.set (x);
}

void SystemConfiguration::
ComponentSet (::std::auto_ptr< ComponentSet_type > x)
{
  this->ComponentSet_.set (x);
}

const SystemConfiguration::CommunicationSet_optional& SystemConfiguration::
CommunicationSet () const
{
  return this->CommunicationSet_;
}

SystemConfiguration::CommunicationSet_optional& SystemConfiguration::
CommunicationSet ()
{
  return this->CommunicationSet_;
}

void SystemConfiguration::
CommunicationSet (const CommunicationSet_type& x)
{
  this->CommunicationSet_.set (x);
}

void SystemConfiguration::
CommunicationSet (const CommunicationSet_optional& x)
{
  this->CommunicationSet_ = x;
}

void SystemConfiguration::
CommunicationSet (::std::auto_ptr< CommunicationSet_type > x)
{
  this->CommunicationSet_.set (x);
}

const SystemConfiguration::AddressSpaceSet_optional& SystemConfiguration::
AddressSpaceSet () const
{
  return this->AddressSpaceSet_;
}

SystemConfiguration::AddressSpaceSet_optional& SystemConfiguration::
AddressSpaceSet ()
{
  return this->AddressSpaceSet_;
}

void SystemConfiguration::
AddressSpaceSet (const AddressSpaceSet_type& x)
{
  this->AddressSpaceSet_.set (x);
}

void SystemConfiguration::
AddressSpaceSet (const AddressSpaceSet_optional& x)
{
  this->AddressSpaceSet_ = x;
}

void SystemConfiguration::
AddressSpaceSet (::std::auto_ptr< AddressSpaceSet_type > x)
{
  this->AddressSpaceSet_.set (x);
}

const SystemConfiguration::ClockFrequency_type& SystemConfiguration::
ClockFrequency () const
{
  return this->ClockFrequency_.get ();
}

SystemConfiguration::ClockFrequency_type& SystemConfiguration::
ClockFrequency ()
{
  return this->ClockFrequency_.get ();
}

void SystemConfiguration::
ClockFrequency (const ClockFrequency_type& x)
{
  this->ClockFrequency_.set (x);
}

void SystemConfiguration::
ClockFrequency (::std::auto_ptr< ClockFrequency_type > x)
{
  this->ClockFrequency_.set (x);
}

const SystemConfiguration::name_type& SystemConfiguration::
name () const
{
  return this->name_.get ();
}

SystemConfiguration::name_type& SystemConfiguration::
name ()
{
  return this->name_.get ();
}

void SystemConfiguration::
name (const name_type& x)
{
  this->name_.set (x);
}

void SystemConfiguration::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const SystemConfiguration::shimVersion_type& SystemConfiguration::
shimVersion () const
{
  return this->shimVersion_.get ();
}

SystemConfiguration::shimVersion_type& SystemConfiguration::
shimVersion ()
{
  return this->shimVersion_.get ();
}

void SystemConfiguration::
shimVersion (const shimVersion_type& x)
{
  this->shimVersion_.set (x);
}

void SystemConfiguration::
shimVersion (::std::auto_ptr< shimVersion_type > x)
{
  this->shimVersion_.set (x);
}


// ConnectionSet
// 

const ConnectionSet::Connection_sequence& ConnectionSet::
Connection () const
{
  return this->Connection_;
}

ConnectionSet::Connection_sequence& ConnectionSet::
Connection ()
{
  return this->Connection_;
}

void ConnectionSet::
Connection (const Connection_sequence& s)
{
  this->Connection_ = s;
}


// CacheCoherencyType
// 

CacheCoherencyType::
CacheCoherencyType (value v)
: ::xml_schema::string (_xsd_CacheCoherencyType_literals_[v])
{
}

CacheCoherencyType::
CacheCoherencyType (const char* v)
: ::xml_schema::string (v)
{
}

CacheCoherencyType::
CacheCoherencyType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

CacheCoherencyType::
CacheCoherencyType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

CacheCoherencyType::
CacheCoherencyType (const CacheCoherencyType& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

CacheCoherencyType& CacheCoherencyType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_CacheCoherencyType_literals_[v]);

  return *this;
}


// MemoryConsistencyModel
// 

const MemoryConsistencyModel::rawOrdering_optional& MemoryConsistencyModel::
rawOrdering () const
{
  return this->rawOrdering_;
}

MemoryConsistencyModel::rawOrdering_optional& MemoryConsistencyModel::
rawOrdering ()
{
  return this->rawOrdering_;
}

void MemoryConsistencyModel::
rawOrdering (const rawOrdering_type& x)
{
  this->rawOrdering_.set (x);
}

void MemoryConsistencyModel::
rawOrdering (const rawOrdering_optional& x)
{
  this->rawOrdering_ = x;
}

void MemoryConsistencyModel::
rawOrdering (::std::auto_ptr< rawOrdering_type > x)
{
  this->rawOrdering_.set (x);
}

const MemoryConsistencyModel::warOrdering_optional& MemoryConsistencyModel::
warOrdering () const
{
  return this->warOrdering_;
}

MemoryConsistencyModel::warOrdering_optional& MemoryConsistencyModel::
warOrdering ()
{
  return this->warOrdering_;
}

void MemoryConsistencyModel::
warOrdering (const warOrdering_type& x)
{
  this->warOrdering_.set (x);
}

void MemoryConsistencyModel::
warOrdering (const warOrdering_optional& x)
{
  this->warOrdering_ = x;
}

void MemoryConsistencyModel::
warOrdering (::std::auto_ptr< warOrdering_type > x)
{
  this->warOrdering_.set (x);
}

const MemoryConsistencyModel::wawOrdering_optional& MemoryConsistencyModel::
wawOrdering () const
{
  return this->wawOrdering_;
}

MemoryConsistencyModel::wawOrdering_optional& MemoryConsistencyModel::
wawOrdering ()
{
  return this->wawOrdering_;
}

void MemoryConsistencyModel::
wawOrdering (const wawOrdering_type& x)
{
  this->wawOrdering_.set (x);
}

void MemoryConsistencyModel::
wawOrdering (const wawOrdering_optional& x)
{
  this->wawOrdering_ = x;
}

void MemoryConsistencyModel::
wawOrdering (::std::auto_ptr< wawOrdering_type > x)
{
  this->wawOrdering_.set (x);
}

const MemoryConsistencyModel::rarOrdering_optional& MemoryConsistencyModel::
rarOrdering () const
{
  return this->rarOrdering_;
}

MemoryConsistencyModel::rarOrdering_optional& MemoryConsistencyModel::
rarOrdering ()
{
  return this->rarOrdering_;
}

void MemoryConsistencyModel::
rarOrdering (const rarOrdering_type& x)
{
  this->rarOrdering_.set (x);
}

void MemoryConsistencyModel::
rarOrdering (const rarOrdering_optional& x)
{
  this->rarOrdering_ = x;
}

void MemoryConsistencyModel::
rarOrdering (::std::auto_ptr< rarOrdering_type > x)
{
  this->rarOrdering_.set (x);
}


// OrderingType
// 

OrderingType::
OrderingType (value v)
: ::xml_schema::string (_xsd_OrderingType_literals_[v])
{
}

OrderingType::
OrderingType (const char* v)
: ::xml_schema::string (v)
{
}

OrderingType::
OrderingType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

OrderingType::
OrderingType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

OrderingType::
OrderingType (const OrderingType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

OrderingType& OrderingType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_OrderingType_literals_[v]);

  return *this;
}


// EndianType
// 

EndianType::
EndianType (value v)
: ::xml_schema::string (_xsd_EndianType_literals_[v])
{
}

EndianType::
EndianType (const char* v)
: ::xml_schema::string (v)
{
}

EndianType::
EndianType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

EndianType::
EndianType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

EndianType::
EndianType (const EndianType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

EndianType& EndianType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_EndianType_literals_[v]);

  return *this;
}


// SharedRegisterCommunication
// 

const SharedRegisterCommunication::dataSize_type& SharedRegisterCommunication::
dataSize () const
{
  return this->dataSize_.get ();
}

SharedRegisterCommunication::dataSize_type& SharedRegisterCommunication::
dataSize ()
{
  return this->dataSize_.get ();
}

void SharedRegisterCommunication::
dataSize (const dataSize_type& x)
{
  this->dataSize_.set (x);
}

const SharedRegisterCommunication::dataSizeUnit_type& SharedRegisterCommunication::
dataSizeUnit () const
{
  return this->dataSizeUnit_.get ();
}

SharedRegisterCommunication::dataSizeUnit_type& SharedRegisterCommunication::
dataSizeUnit ()
{
  return this->dataSizeUnit_.get ();
}

void SharedRegisterCommunication::
dataSizeUnit (const dataSizeUnit_type& x)
{
  this->dataSizeUnit_.set (x);
}

void SharedRegisterCommunication::
dataSizeUnit (::std::auto_ptr< dataSizeUnit_type > x)
{
  this->dataSizeUnit_.set (x);
}

const SharedRegisterCommunication::nRegister_type& SharedRegisterCommunication::
nRegister () const
{
  return this->nRegister_.get ();
}

SharedRegisterCommunication::nRegister_type& SharedRegisterCommunication::
nRegister ()
{
  return this->nRegister_.get ();
}

void SharedRegisterCommunication::
nRegister (const nRegister_type& x)
{
  this->nRegister_.set (x);
}


// SharedMemoryCommunication
// 

const SharedMemoryCommunication::operationType_optional& SharedMemoryCommunication::
operationType () const
{
  return this->operationType_;
}

SharedMemoryCommunication::operationType_optional& SharedMemoryCommunication::
operationType ()
{
  return this->operationType_;
}

void SharedMemoryCommunication::
operationType (const operationType_type& x)
{
  this->operationType_.set (x);
}

void SharedMemoryCommunication::
operationType (const operationType_optional& x)
{
  this->operationType_ = x;
}

void SharedMemoryCommunication::
operationType (::std::auto_ptr< operationType_type > x)
{
  this->operationType_.set (x);
}

const SharedMemoryCommunication::dataSize_optional& SharedMemoryCommunication::
dataSize () const
{
  return this->dataSize_;
}

SharedMemoryCommunication::dataSize_optional& SharedMemoryCommunication::
dataSize ()
{
  return this->dataSize_;
}

void SharedMemoryCommunication::
dataSize (const dataSize_type& x)
{
  this->dataSize_.set (x);
}

void SharedMemoryCommunication::
dataSize (const dataSize_optional& x)
{
  this->dataSize_ = x;
}

const SharedMemoryCommunication::dataSizeUnit_optional& SharedMemoryCommunication::
dataSizeUnit () const
{
  return this->dataSizeUnit_;
}

SharedMemoryCommunication::dataSizeUnit_optional& SharedMemoryCommunication::
dataSizeUnit ()
{
  return this->dataSizeUnit_;
}

void SharedMemoryCommunication::
dataSizeUnit (const dataSizeUnit_type& x)
{
  this->dataSizeUnit_.set (x);
}

void SharedMemoryCommunication::
dataSizeUnit (const dataSizeUnit_optional& x)
{
  this->dataSizeUnit_ = x;
}

void SharedMemoryCommunication::
dataSizeUnit (::std::auto_ptr< dataSizeUnit_type > x)
{
  this->dataSizeUnit_.set (x);
}

const SharedMemoryCommunication::addressSpaceRef_optional& SharedMemoryCommunication::
addressSpaceRef () const
{
  return this->addressSpaceRef_;
}

SharedMemoryCommunication::addressSpaceRef_optional& SharedMemoryCommunication::
addressSpaceRef ()
{
  return this->addressSpaceRef_;
}

void SharedMemoryCommunication::
addressSpaceRef (const addressSpaceRef_type& x)
{
  this->addressSpaceRef_.set (x);
}

void SharedMemoryCommunication::
addressSpaceRef (const addressSpaceRef_optional& x)
{
  this->addressSpaceRef_ = x;
}

void SharedMemoryCommunication::
addressSpaceRef (::std::auto_ptr< addressSpaceRef_type > x)
{
  this->addressSpaceRef_.set (x);
}

const SharedMemoryCommunication::subSpaceRef_optional& SharedMemoryCommunication::
subSpaceRef () const
{
  return this->subSpaceRef_;
}

SharedMemoryCommunication::subSpaceRef_optional& SharedMemoryCommunication::
subSpaceRef ()
{
  return this->subSpaceRef_;
}

void SharedMemoryCommunication::
subSpaceRef (const subSpaceRef_type& x)
{
  this->subSpaceRef_.set (x);
}

void SharedMemoryCommunication::
subSpaceRef (const subSpaceRef_optional& x)
{
  this->subSpaceRef_ = x;
}

void SharedMemoryCommunication::
subSpaceRef (::std::auto_ptr< subSpaceRef_type > x)
{
  this->subSpaceRef_.set (x);
}


// EventCommunication
// 


// ClockFrequency
// 

const ClockFrequency::clockValue_type& ClockFrequency::
clockValue () const
{
  return this->clockValue_.get ();
}

ClockFrequency::clockValue_type& ClockFrequency::
clockValue ()
{
  return this->clockValue_.get ();
}

void ClockFrequency::
clockValue (const clockValue_type& x)
{
  this->clockValue_.set (x);
}


// Accessor
// 

const Accessor::PerformanceSet_sequence& Accessor::
PerformanceSet () const
{
  return this->PerformanceSet_;
}

Accessor::PerformanceSet_sequence& Accessor::
PerformanceSet ()
{
  return this->PerformanceSet_;
}

void Accessor::
PerformanceSet (const PerformanceSet_sequence& s)
{
  this->PerformanceSet_ = s;
}

const Accessor::masterComponentRef_type& Accessor::
masterComponentRef () const
{
  return this->masterComponentRef_.get ();
}

Accessor::masterComponentRef_type& Accessor::
masterComponentRef ()
{
  return this->masterComponentRef_.get ();
}

void Accessor::
masterComponentRef (const masterComponentRef_type& x)
{
  this->masterComponentRef_.set (x);
}

void Accessor::
masterComponentRef (::std::auto_ptr< masterComponentRef_type > x)
{
  this->masterComponentRef_.set (x);
}


// AccessType
// 

const AccessType::name_type& AccessType::
name () const
{
  return this->name_.get ();
}

AccessType::name_type& AccessType::
name ()
{
  return this->name_.get ();
}

void AccessType::
name (const name_type& x)
{
  this->name_.set (x);
}

void AccessType::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const AccessType::id_type& AccessType::
id () const
{
  return this->id_.get ();
}

AccessType::id_type& AccessType::
id ()
{
  return this->id_.get ();
}

void AccessType::
id (const id_type& x)
{
  this->id_.set (x);
}

void AccessType::
id (::std::auto_ptr< id_type > x)
{
  this->id_.set (x);
}

const AccessType::rwType_optional& AccessType::
rwType () const
{
  return this->rwType_;
}

AccessType::rwType_optional& AccessType::
rwType ()
{
  return this->rwType_;
}

void AccessType::
rwType (const rwType_type& x)
{
  this->rwType_.set (x);
}

void AccessType::
rwType (const rwType_optional& x)
{
  this->rwType_ = x;
}

void AccessType::
rwType (::std::auto_ptr< rwType_type > x)
{
  this->rwType_.set (x);
}

const AccessType::accessByteSize_optional& AccessType::
accessByteSize () const
{
  return this->accessByteSize_;
}

AccessType::accessByteSize_optional& AccessType::
accessByteSize ()
{
  return this->accessByteSize_;
}

void AccessType::
accessByteSize (const accessByteSize_type& x)
{
  this->accessByteSize_.set (x);
}

void AccessType::
accessByteSize (const accessByteSize_optional& x)
{
  this->accessByteSize_ = x;
}

const AccessType::alignmentByteSize_optional& AccessType::
alignmentByteSize () const
{
  return this->alignmentByteSize_;
}

AccessType::alignmentByteSize_optional& AccessType::
alignmentByteSize ()
{
  return this->alignmentByteSize_;
}

void AccessType::
alignmentByteSize (const alignmentByteSize_type& x)
{
  this->alignmentByteSize_.set (x);
}

void AccessType::
alignmentByteSize (const alignmentByteSize_optional& x)
{
  this->alignmentByteSize_ = x;
}

const AccessType::nBurst_optional& AccessType::
nBurst () const
{
  return this->nBurst_;
}

AccessType::nBurst_optional& AccessType::
nBurst ()
{
  return this->nBurst_;
}

void AccessType::
nBurst (const nBurst_type& x)
{
  this->nBurst_.set (x);
}

void AccessType::
nBurst (const nBurst_optional& x)
{
  this->nBurst_ = x;
}


// MasterSlaveBindingSet
// 

const MasterSlaveBindingSet::MasterSlaveBinding_sequence& MasterSlaveBindingSet::
MasterSlaveBinding () const
{
  return this->MasterSlaveBinding_;
}

MasterSlaveBindingSet::MasterSlaveBinding_sequence& MasterSlaveBindingSet::
MasterSlaveBinding ()
{
  return this->MasterSlaveBinding_;
}

void MasterSlaveBindingSet::
MasterSlaveBinding (const MasterSlaveBinding_sequence& s)
{
  this->MasterSlaveBinding_ = s;
}


// CacheType
// 

CacheType::
CacheType (value v)
: ::xml_schema::string (_xsd_CacheType_literals_[v])
{
}

CacheType::
CacheType (const char* v)
: ::xml_schema::string (v)
{
}

CacheType::
CacheType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

CacheType::
CacheType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

CacheType::
CacheType (const CacheType& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

CacheType& CacheType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_CacheType_literals_[v]);

  return *this;
}


// Performance
// 

const Performance::Pitch_type& Performance::
Pitch () const
{
  return this->Pitch_.get ();
}

Performance::Pitch_type& Performance::
Pitch ()
{
  return this->Pitch_.get ();
}

void Performance::
Pitch (const Pitch_type& x)
{
  this->Pitch_.set (x);
}

void Performance::
Pitch (::std::auto_ptr< Pitch_type > x)
{
  this->Pitch_.set (x);
}

const Performance::Latency_type& Performance::
Latency () const
{
  return this->Latency_.get ();
}

Performance::Latency_type& Performance::
Latency ()
{
  return this->Latency_.get ();
}

void Performance::
Latency (const Latency_type& x)
{
  this->Latency_.set (x);
}

void Performance::
Latency (::std::auto_ptr< Latency_type > x)
{
  this->Latency_.set (x);
}

const Performance::accessTypeRef_optional& Performance::
accessTypeRef () const
{
  return this->accessTypeRef_;
}

Performance::accessTypeRef_optional& Performance::
accessTypeRef ()
{
  return this->accessTypeRef_;
}

void Performance::
accessTypeRef (const accessTypeRef_type& x)
{
  this->accessTypeRef_.set (x);
}

void Performance::
accessTypeRef (const accessTypeRef_optional& x)
{
  this->accessTypeRef_ = x;
}

void Performance::
accessTypeRef (::std::auto_ptr< accessTypeRef_type > x)
{
  this->accessTypeRef_.set (x);
}


// AccessTypeSet
// 

const AccessTypeSet::AccessType_sequence& AccessTypeSet::
AccessType () const
{
  return this->AccessType_;
}

AccessTypeSet::AccessType_sequence& AccessTypeSet::
AccessType ()
{
  return this->AccessType_;
}

void AccessTypeSet::
AccessType (const AccessType_sequence& s)
{
  this->AccessType_ = s;
}


// SizeUnitType
// 

SizeUnitType::
SizeUnitType (value v)
: ::xml_schema::string (_xsd_SizeUnitType_literals_[v])
{
}

SizeUnitType::
SizeUnitType (const char* v)
: ::xml_schema::string (v)
{
}

SizeUnitType::
SizeUnitType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

SizeUnitType::
SizeUnitType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

SizeUnitType::
SizeUnitType (const SizeUnitType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

SizeUnitType& SizeUnitType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_SizeUnitType_literals_[v]);

  return *this;
}


// LockDownType
// 

LockDownType::
LockDownType (value v)
: ::xml_schema::string (_xsd_LockDownType_literals_[v])
{
}

LockDownType::
LockDownType (const char* v)
: ::xml_schema::string (v)
{
}

LockDownType::
LockDownType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

LockDownType::
LockDownType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

LockDownType::
LockDownType (const LockDownType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

LockDownType& LockDownType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_LockDownType_literals_[v]);

  return *this;
}


// OperationType
// 

OperationType::
OperationType (value v)
: ::xml_schema::string (_xsd_OperationType_literals_[v])
{
}

OperationType::
OperationType (const char* v)
: ::xml_schema::string (v)
{
}

OperationType::
OperationType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

OperationType::
OperationType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

OperationType::
OperationType (const OperationType& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

OperationType& OperationType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_OperationType_literals_[v]);

  return *this;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// ComponentSet
//

ComponentSet::
ComponentSet (const name_type& name)
: ::xml_schema::type (),
  ComponentSet1_ (this),
  SlaveComponent_ (this),
  MasterComponent_ (this),
  Cache_ (this),
  name_ (name, this)
{
}

ComponentSet::
ComponentSet (const ComponentSet& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ComponentSet1_ (x.ComponentSet1_, f, this),
  SlaveComponent_ (x.SlaveComponent_, f, this),
  MasterComponent_ (x.MasterComponent_, f, this),
  Cache_ (x.Cache_, f, this),
  name_ (x.name_, f, this)
{
}

ComponentSet::
ComponentSet (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ComponentSet1_ (this),
  SlaveComponent_ (this),
  MasterComponent_ (this),
  Cache_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ComponentSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ComponentSet
    //
    if (n.name () == "ComponentSet" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ComponentSet1_type > r (
        ComponentSet1_traits::create (i, f, this));

      this->ComponentSet1_.push_back (r);
      continue;
    }

    // SlaveComponent
    //
    if (n.name () == "SlaveComponent" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SlaveComponent_type > r (
        SlaveComponent_traits::create (i, f, this));

      this->SlaveComponent_.push_back (r);
      continue;
    }

    // MasterComponent
    //
    if (n.name () == "MasterComponent" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MasterComponent_type > r (
        MasterComponent_traits::create (i, f, this));

      this->MasterComponent_.push_back (r);
      continue;
    }

    // Cache
    //
    if (n.name () == "Cache" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Cache_type > r (
        Cache_traits::create (i, f, this));

      this->Cache_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

ComponentSet* ComponentSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ComponentSet (*this, f, c);
}

ComponentSet& ComponentSet::
operator= (const ComponentSet& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ComponentSet1_ = x.ComponentSet1_;
    this->SlaveComponent_ = x.SlaveComponent_;
    this->MasterComponent_ = x.MasterComponent_;
    this->Cache_ = x.Cache_;
    this->name_ = x.name_;
  }

  return *this;
}

ComponentSet::
~ComponentSet ()
{
}

// SlaveComponent
//

SlaveComponent::
SlaveComponent (const name_type& name,
                const id_type& id,
                const size_type& size,
                const sizeUnit_type& sizeUnit,
                const rwType_type& rwType)
: ::xml_schema::type (),
  name_ (name, this),
  id_ (id, this),
  size_ (size, this),
  sizeUnit_ (sizeUnit, this),
  rwType_ (rwType, this)
{
}

SlaveComponent::
SlaveComponent (const SlaveComponent& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  size_ (x.size_, f, this),
  sizeUnit_ (x.sizeUnit_, f, this),
  rwType_ (x.rwType_, f, this)
{
}

SlaveComponent::
SlaveComponent (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  id_ (this),
  size_ (this),
  sizeUnit_ (this),
  rwType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void SlaveComponent::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "size" && n.namespace_ ().empty ())
    {
      this->size_.set (size_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sizeUnit" && n.namespace_ ().empty ())
    {
      this->sizeUnit_.set (sizeUnit_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rwType" && n.namespace_ ().empty ())
    {
      this->rwType_.set (rwType_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!size_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "size",
      "");
  }

  if (!sizeUnit_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sizeUnit",
      "");
  }

  if (!rwType_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "rwType",
      "");
  }
}

SlaveComponent* SlaveComponent::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SlaveComponent (*this, f, c);
}

SlaveComponent& SlaveComponent::
operator= (const SlaveComponent& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->size_ = x.size_;
    this->sizeUnit_ = x.sizeUnit_;
    this->rwType_ = x.rwType_;
  }

  return *this;
}

SlaveComponent::
~SlaveComponent ()
{
}

// MasterComponent
//

MasterComponent::
MasterComponent (const AccessTypeSet_type& AccessTypeSet,
                 const name_type& name,
                 const id_type& id,
                 const masterType_type& masterType,
                 const arch_type& arch)
: ::xml_schema::type (),
  CommonInstructionSet_ (this),
  Cache_ (this),
  ClockFrequency_ (this),
  AccessTypeSet_ (AccessTypeSet, this),
  name_ (name, this),
  id_ (id, this),
  masterType_ (masterType, this),
  arch_ (arch, this),
  archOption_ (this),
  pid_ (this),
  nThread_ (this),
  endian_ (this)
{
}

MasterComponent::
MasterComponent (::std::auto_ptr< AccessTypeSet_type > AccessTypeSet,
                 const name_type& name,
                 const id_type& id,
                 const masterType_type& masterType,
                 const arch_type& arch)
: ::xml_schema::type (),
  CommonInstructionSet_ (this),
  Cache_ (this),
  ClockFrequency_ (this),
  AccessTypeSet_ (AccessTypeSet, this),
  name_ (name, this),
  id_ (id, this),
  masterType_ (masterType, this),
  arch_ (arch, this),
  archOption_ (this),
  pid_ (this),
  nThread_ (this),
  endian_ (this)
{
}

MasterComponent::
MasterComponent (const MasterComponent& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  CommonInstructionSet_ (x.CommonInstructionSet_, f, this),
  Cache_ (x.Cache_, f, this),
  ClockFrequency_ (x.ClockFrequency_, f, this),
  AccessTypeSet_ (x.AccessTypeSet_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  masterType_ (x.masterType_, f, this),
  arch_ (x.arch_, f, this),
  archOption_ (x.archOption_, f, this),
  pid_ (x.pid_, f, this),
  nThread_ (x.nThread_, f, this),
  endian_ (x.endian_, f, this)
{
}

MasterComponent::
MasterComponent (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  CommonInstructionSet_ (this),
  Cache_ (this),
  ClockFrequency_ (this),
  AccessTypeSet_ (this),
  name_ (this),
  id_ (this),
  masterType_ (this),
  arch_ (this),
  archOption_ (this),
  pid_ (this),
  nThread_ (this),
  endian_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void MasterComponent::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CommonInstructionSet
    //
    if (n.name () == "CommonInstructionSet" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CommonInstructionSet_type > r (
        CommonInstructionSet_traits::create (i, f, this));

      if (!this->CommonInstructionSet_)
      {
        this->CommonInstructionSet_.set (r);
        continue;
      }
    }

    // Cache
    //
    if (n.name () == "Cache" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Cache_type > r (
        Cache_traits::create (i, f, this));

      this->Cache_.push_back (r);
      continue;
    }

    // ClockFrequency
    //
    if (n.name () == "ClockFrequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ClockFrequency_type > r (
        ClockFrequency_traits::create (i, f, this));

      if (!this->ClockFrequency_)
      {
        this->ClockFrequency_.set (r);
        continue;
      }
    }

    // AccessTypeSet
    //
    if (n.name () == "AccessTypeSet" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AccessTypeSet_type > r (
        AccessTypeSet_traits::create (i, f, this));

      if (!AccessTypeSet_.present ())
      {
        this->AccessTypeSet_.set (r);
        continue;
      }
    }

    break;
  }

  if (!AccessTypeSet_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AccessTypeSet",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "masterType" && n.namespace_ ().empty ())
    {
      this->masterType_.set (masterType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "arch" && n.namespace_ ().empty ())
    {
      this->arch_.set (arch_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "archOption" && n.namespace_ ().empty ())
    {
      this->archOption_.set (archOption_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "pid" && n.namespace_ ().empty ())
    {
      this->pid_.set (pid_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "nThread" && n.namespace_ ().empty ())
    {
      this->nThread_.set (nThread_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "endian" && n.namespace_ ().empty ())
    {
      this->endian_.set (endian_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!masterType_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "masterType",
      "");
  }

  if (!arch_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "arch",
      "");
  }
}

MasterComponent* MasterComponent::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MasterComponent (*this, f, c);
}

MasterComponent& MasterComponent::
operator= (const MasterComponent& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->CommonInstructionSet_ = x.CommonInstructionSet_;
    this->Cache_ = x.Cache_;
    this->ClockFrequency_ = x.ClockFrequency_;
    this->AccessTypeSet_ = x.AccessTypeSet_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->masterType_ = x.masterType_;
    this->arch_ = x.arch_;
    this->archOption_ = x.archOption_;
    this->pid_ = x.pid_;
    this->nThread_ = x.nThread_;
    this->endian_ = x.endian_;
  }

  return *this;
}

MasterComponent::
~MasterComponent ()
{
}

// RWType
//

RWType::
RWType (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RWType_convert ();
}

RWType::
RWType (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RWType_convert ();
}

RWType::
RWType (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RWType_convert ();
}

RWType* RWType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RWType (*this, f, c);
}

RWType::value RWType::
_xsd_RWType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RWType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RWType_indexes_,
                    _xsd_RWType_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_RWType_indexes_ + 7 || _xsd_RWType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RWType::
_xsd_RWType_literals_[7] =
{
  "RW",
  "WX",
  "RX",
  "R",
  "W",
  "X",
  "RWX"
};

const RWType::value RWType::
_xsd_RWType_indexes_[7] =
{
  ::RWType::R,
  ::RWType::RW,
  ::RWType::RWX,
  ::RWType::RX,
  ::RWType::W,
  ::RWType::WX,
  ::RWType::X
};

// AddressSpaceSet
//

AddressSpaceSet::
AddressSpaceSet ()
: ::xml_schema::type (),
  AddressSpace_ (this)
{
}

AddressSpaceSet::
AddressSpaceSet (const AddressSpaceSet& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  AddressSpace_ (x.AddressSpace_, f, this)
{
}

AddressSpaceSet::
AddressSpaceSet (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  AddressSpace_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void AddressSpaceSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AddressSpace
    //
    if (n.name () == "AddressSpace" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AddressSpace_type > r (
        AddressSpace_traits::create (i, f, this));

      this->AddressSpace_.push_back (r);
      continue;
    }

    break;
  }
}

AddressSpaceSet* AddressSpaceSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AddressSpaceSet (*this, f, c);
}

AddressSpaceSet& AddressSpaceSet::
operator= (const AddressSpaceSet& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->AddressSpace_ = x.AddressSpace_;
  }

  return *this;
}

AddressSpaceSet::
~AddressSpaceSet ()
{
}

// AddressSpace
//

AddressSpace::
AddressSpace (const name_type& name,
              const id_type& id)
: ::xml_schema::type (),
  SubSpace_ (this),
  name_ (name, this),
  id_ (id, this)
{
}

AddressSpace::
AddressSpace (const AddressSpace& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  SubSpace_ (x.SubSpace_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this)
{
}

AddressSpace::
AddressSpace (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  SubSpace_ (this),
  name_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void AddressSpace::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // SubSpace
    //
    if (n.name () == "SubSpace" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SubSpace_type > r (
        SubSpace_traits::create (i, f, this));

      this->SubSpace_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

AddressSpace* AddressSpace::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AddressSpace (*this, f, c);
}

AddressSpace& AddressSpace::
operator= (const AddressSpace& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->SubSpace_ = x.SubSpace_;
    this->name_ = x.name_;
    this->id_ = x.id_;
  }

  return *this;
}

AddressSpace::
~AddressSpace ()
{
}

// SubSpace
//

SubSpace::
SubSpace (const name_type& name,
          const id_type& id,
          const start_type& start,
          const end_type& end)
: ::xml_schema::type (),
  MemoryConsistencyModel_ (this),
  MasterSlaveBindingSet_ (this),
  name_ (name, this),
  id_ (id, this),
  start_ (start, this),
  end_ (end, this),
  endian_ (this)
{
}

SubSpace::
SubSpace (const SubSpace& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  MemoryConsistencyModel_ (x.MemoryConsistencyModel_, f, this),
  MasterSlaveBindingSet_ (x.MasterSlaveBindingSet_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  start_ (x.start_, f, this),
  end_ (x.end_, f, this),
  endian_ (x.endian_, f, this)
{
}

SubSpace::
SubSpace (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  MemoryConsistencyModel_ (this),
  MasterSlaveBindingSet_ (this),
  name_ (this),
  id_ (this),
  start_ (this),
  end_ (this),
  endian_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void SubSpace::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // MemoryConsistencyModel
    //
    if (n.name () == "MemoryConsistencyModel" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MemoryConsistencyModel_type > r (
        MemoryConsistencyModel_traits::create (i, f, this));

      this->MemoryConsistencyModel_.push_back (r);
      continue;
    }

    // MasterSlaveBindingSet
    //
    if (n.name () == "MasterSlaveBindingSet" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MasterSlaveBindingSet_type > r (
        MasterSlaveBindingSet_traits::create (i, f, this));

      if (!this->MasterSlaveBindingSet_)
      {
        this->MasterSlaveBindingSet_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "start" && n.namespace_ ().empty ())
    {
      this->start_.set (start_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "end" && n.namespace_ ().empty ())
    {
      this->end_.set (end_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "endian" && n.namespace_ ().empty ())
    {
      this->endian_.set (endian_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!start_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "start",
      "");
  }

  if (!end_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "end",
      "");
  }
}

SubSpace* SubSpace::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SubSpace (*this, f, c);
}

SubSpace& SubSpace::
operator= (const SubSpace& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->MemoryConsistencyModel_ = x.MemoryConsistencyModel_;
    this->MasterSlaveBindingSet_ = x.MasterSlaveBindingSet_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->start_ = x.start_;
    this->end_ = x.end_;
    this->endian_ = x.endian_;
  }

  return *this;
}

SubSpace::
~SubSpace ()
{
}

// MasterType
//

MasterType::
MasterType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_MasterType_convert ();
}

MasterType::
MasterType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_MasterType_convert ();
}

MasterType::
MasterType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_MasterType_convert ();
}

MasterType* MasterType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MasterType (*this, f, c);
}

MasterType::value MasterType::
_xsd_MasterType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MasterType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_MasterType_indexes_,
                    _xsd_MasterType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_MasterType_indexes_ + 3 || _xsd_MasterType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const MasterType::
_xsd_MasterType_literals_[3] =
{
  "PU",
  "TU",
  "OTHER"
};

const MasterType::value MasterType::
_xsd_MasterType_indexes_[3] =
{
  ::MasterType::OTHER,
  ::MasterType::PU,
  ::MasterType::TU
};

// Instruction
//

Instruction::
Instruction (const Performance_type& Performance,
             const name_type& name)
: ::xml_schema::type (),
  Performance_ (Performance, this),
  name_ (name, this)
{
}

Instruction::
Instruction (::std::auto_ptr< Performance_type > Performance,
             const name_type& name)
: ::xml_schema::type (),
  Performance_ (Performance, this),
  name_ (name, this)
{
}

Instruction::
Instruction (const Instruction& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Performance_ (x.Performance_, f, this),
  name_ (x.name_, f, this)
{
}

Instruction::
Instruction (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Performance_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Instruction::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Performance
    //
    if (n.name () == "Performance" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Performance_type > r (
        Performance_traits::create (i, f, this));

      if (!Performance_.present ())
      {
        this->Performance_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Performance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Performance",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

Instruction* Instruction::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Instruction (*this, f, c);
}

Instruction& Instruction::
operator= (const Instruction& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Performance_ = x.Performance_;
    this->name_ = x.name_;
  }

  return *this;
}

Instruction::
~Instruction ()
{
}

// AbstractCommunication
//

AbstractCommunication::
AbstractCommunication (const name_type& name)
: ::xml_schema::type (),
  ConnectionSet_ (this),
  name_ (name, this)
{
}

AbstractCommunication::
AbstractCommunication (const AbstractCommunication& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ConnectionSet_ (x.ConnectionSet_, f, this),
  name_ (x.name_, f, this)
{
}

AbstractCommunication::
AbstractCommunication (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ConnectionSet_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void AbstractCommunication::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ConnectionSet
    //
    if (n.name () == "ConnectionSet" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ConnectionSet_type > r (
        ConnectionSet_traits::create (i, f, this));

      if (!this->ConnectionSet_)
      {
        this->ConnectionSet_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

AbstractCommunication* AbstractCommunication::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AbstractCommunication (*this, f, c);
}

AbstractCommunication& AbstractCommunication::
operator= (const AbstractCommunication& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ConnectionSet_ = x.ConnectionSet_;
    this->name_ = x.name_;
  }

  return *this;
}

AbstractCommunication::
~AbstractCommunication ()
{
}

// InterruptCommunication
//

InterruptCommunication::
InterruptCommunication (const name_type& name)
: ::AbstractCommunication (name)
{
}

InterruptCommunication::
InterruptCommunication (const InterruptCommunication& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::AbstractCommunication (x, f, c)
{
}

InterruptCommunication::
InterruptCommunication (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::AbstractCommunication (e, f, c)
{
}

InterruptCommunication* InterruptCommunication::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class InterruptCommunication (*this, f, c);
}

InterruptCommunication::
~InterruptCommunication ()
{
}

// AbstractPerformance
//

AbstractPerformance::
AbstractPerformance (const typical_type& typical)
: ::xml_schema::type (),
  best_ (this),
  typical_ (typical, this),
  worst_ (this)
{
}

AbstractPerformance::
AbstractPerformance (const AbstractPerformance& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  best_ (x.best_, f, this),
  typical_ (x.typical_, f, this),
  worst_ (x.worst_, f, this)
{
}

AbstractPerformance::
AbstractPerformance (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  best_ (this),
  typical_ (this),
  worst_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void AbstractPerformance::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "best" && n.namespace_ ().empty ())
    {
      this->best_.set (best_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "typical" && n.namespace_ ().empty ())
    {
      this->typical_.set (typical_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "worst" && n.namespace_ ().empty ())
    {
      this->worst_.set (worst_traits::create (i, f, this));
      continue;
    }
  }

  if (!typical_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "typical",
      "");
  }
}

AbstractPerformance* AbstractPerformance::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AbstractPerformance (*this, f, c);
}

AbstractPerformance& AbstractPerformance::
operator= (const AbstractPerformance& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->best_ = x.best_;
    this->typical_ = x.typical_;
    this->worst_ = x.worst_;
  }

  return *this;
}

AbstractPerformance::
~AbstractPerformance ()
{
}

// Latency
//

Latency::
Latency (const typical_type& typical)
: ::AbstractPerformance (typical)
{
}

Latency::
Latency (const Latency& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::AbstractPerformance (x, f, c)
{
}

Latency::
Latency (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::AbstractPerformance (e, f, c)
{
}

Latency* Latency::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Latency (*this, f, c);
}

Latency::
~Latency ()
{
}

// Pitch
//

Pitch::
Pitch (const typical_type& typical)
: ::AbstractPerformance (typical)
{
}

Pitch::
Pitch (const Pitch& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::AbstractPerformance (x, f, c)
{
}

Pitch::
Pitch (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::AbstractPerformance (e, f, c)
{
}

Pitch* Pitch::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Pitch (*this, f, c);
}

Pitch::
~Pitch ()
{
}

// MasterSlaveBinding
//

MasterSlaveBinding::
MasterSlaveBinding (const slaveComponentRef_type& slaveComponentRef)
: ::xml_schema::type (),
  Accessor_ (this),
  slaveComponentRef_ (slaveComponentRef, this)
{
}

MasterSlaveBinding::
MasterSlaveBinding (const MasterSlaveBinding& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Accessor_ (x.Accessor_, f, this),
  slaveComponentRef_ (x.slaveComponentRef_, f, this)
{
}

MasterSlaveBinding::
MasterSlaveBinding (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Accessor_ (this),
  slaveComponentRef_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void MasterSlaveBinding::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Accessor
    //
    if (n.name () == "Accessor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Accessor_type > r (
        Accessor_traits::create (i, f, this));

      this->Accessor_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "slaveComponentRef" && n.namespace_ ().empty ())
    {
      this->slaveComponentRef_.set (slaveComponentRef_traits::create (i, f, this));
      continue;
    }
  }

  if (!slaveComponentRef_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "slaveComponentRef",
      "");
  }
}

MasterSlaveBinding* MasterSlaveBinding::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MasterSlaveBinding (*this, f, c);
}

MasterSlaveBinding& MasterSlaveBinding::
operator= (const MasterSlaveBinding& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Accessor_ = x.Accessor_;
    this->slaveComponentRef_ = x.slaveComponentRef_;
  }

  return *this;
}

MasterSlaveBinding::
~MasterSlaveBinding ()
{
}

// CommunicationSet
//

CommunicationSet::
CommunicationSet ()
: ::xml_schema::type (),
  SharedRegisterCommunication_ (this),
  SharedMemoryCommunication_ (this),
  EventCommunication_ (this),
  FIFOCommunication_ (this),
  InterruptCommunication_ (this)
{
}

CommunicationSet::
CommunicationSet (const CommunicationSet& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  SharedRegisterCommunication_ (x.SharedRegisterCommunication_, f, this),
  SharedMemoryCommunication_ (x.SharedMemoryCommunication_, f, this),
  EventCommunication_ (x.EventCommunication_, f, this),
  FIFOCommunication_ (x.FIFOCommunication_, f, this),
  InterruptCommunication_ (x.InterruptCommunication_, f, this)
{
}

CommunicationSet::
CommunicationSet (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  SharedRegisterCommunication_ (this),
  SharedMemoryCommunication_ (this),
  EventCommunication_ (this),
  FIFOCommunication_ (this),
  InterruptCommunication_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CommunicationSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // SharedRegisterCommunication
    //
    if (n.name () == "SharedRegisterCommunication" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SharedRegisterCommunication_type > r (
        SharedRegisterCommunication_traits::create (i, f, this));

      this->SharedRegisterCommunication_.push_back (r);
      continue;
    }

    // SharedMemoryCommunication
    //
    if (n.name () == "SharedMemoryCommunication" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SharedMemoryCommunication_type > r (
        SharedMemoryCommunication_traits::create (i, f, this));

      this->SharedMemoryCommunication_.push_back (r);
      continue;
    }

    // EventCommunication
    //
    if (n.name () == "EventCommunication" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EventCommunication_type > r (
        EventCommunication_traits::create (i, f, this));

      this->EventCommunication_.push_back (r);
      continue;
    }

    // FIFOCommunication
    //
    if (n.name () == "FIFOCommunication" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FIFOCommunication_type > r (
        FIFOCommunication_traits::create (i, f, this));

      this->FIFOCommunication_.push_back (r);
      continue;
    }

    // InterruptCommunication
    //
    if (n.name () == "InterruptCommunication" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< InterruptCommunication_type > r (
        InterruptCommunication_traits::create (i, f, this));

      this->InterruptCommunication_.push_back (r);
      continue;
    }

    break;
  }
}

CommunicationSet* CommunicationSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CommunicationSet (*this, f, c);
}

CommunicationSet& CommunicationSet::
operator= (const CommunicationSet& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->SharedRegisterCommunication_ = x.SharedRegisterCommunication_;
    this->SharedMemoryCommunication_ = x.SharedMemoryCommunication_;
    this->EventCommunication_ = x.EventCommunication_;
    this->FIFOCommunication_ = x.FIFOCommunication_;
    this->InterruptCommunication_ = x.InterruptCommunication_;
  }

  return *this;
}

CommunicationSet::
~CommunicationSet ()
{
}

// Connection
//

Connection::
Connection (const from_type& from,
            const to_type& to)
: ::xml_schema::type (),
  Performance_ (this),
  from_ (from, this),
  to_ (to, this)
{
}

Connection::
Connection (const Connection& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Performance_ (x.Performance_, f, this),
  from_ (x.from_, f, this),
  to_ (x.to_, f, this)
{
}

Connection::
Connection (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Performance_ (this),
  from_ (this),
  to_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Connection::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Performance
    //
    if (n.name () == "Performance" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Performance_type > r (
        Performance_traits::create (i, f, this));

      this->Performance_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "from" && n.namespace_ ().empty ())
    {
      this->from_.set (from_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "to" && n.namespace_ ().empty ())
    {
      this->to_.set (to_traits::create (i, f, this));
      continue;
    }
  }

  if (!from_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "from",
      "");
  }

  if (!to_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "to",
      "");
  }
}

Connection* Connection::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Connection (*this, f, c);
}

Connection& Connection::
operator= (const Connection& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Performance_ = x.Performance_;
    this->from_ = x.from_;
    this->to_ = x.to_;
  }

  return *this;
}

Connection::
~Connection ()
{
}

// PerformanceSet
//

PerformanceSet::
PerformanceSet ()
: ::xml_schema::type (),
  Performance_ (this)
{
}

PerformanceSet::
PerformanceSet (const PerformanceSet& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Performance_ (x.Performance_, f, this)
{
}

PerformanceSet::
PerformanceSet (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Performance_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PerformanceSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Performance
    //
    if (n.name () == "Performance" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Performance_type > r (
        Performance_traits::create (i, f, this));

      this->Performance_.push_back (r);
      continue;
    }

    break;
  }
}

PerformanceSet* PerformanceSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PerformanceSet (*this, f, c);
}

PerformanceSet& PerformanceSet::
operator= (const PerformanceSet& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Performance_ = x.Performance_;
  }

  return *this;
}

PerformanceSet::
~PerformanceSet ()
{
}

// FIFOCommunication
//

FIFOCommunication::
FIFOCommunication (const name_type& name,
                   const dataSize_type& dataSize,
                   const queueSize_type& queueSize)
: ::AbstractCommunication (name),
  dataSize_ (dataSize, this),
  dataSizeUnit_ (this),
  queueSize_ (queueSize, this)
{
}

FIFOCommunication::
FIFOCommunication (const FIFOCommunication& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::AbstractCommunication (x, f, c),
  dataSize_ (x.dataSize_, f, this),
  dataSizeUnit_ (x.dataSizeUnit_, f, this),
  queueSize_ (x.queueSize_, f, this)
{
}

FIFOCommunication::
FIFOCommunication (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::AbstractCommunication (e, f | ::xml_schema::flags::base, c),
  dataSize_ (this),
  dataSizeUnit_ (this),
  queueSize_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void FIFOCommunication::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::AbstractCommunication::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "dataSize" && n.namespace_ ().empty ())
    {
      this->dataSize_.set (dataSize_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dataSizeUnit" && n.namespace_ ().empty ())
    {
      this->dataSizeUnit_.set (dataSizeUnit_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "queueSize" && n.namespace_ ().empty ())
    {
      this->queueSize_.set (queueSize_traits::create (i, f, this));
      continue;
    }
  }

  if (!dataSize_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dataSize",
      "");
  }

  if (!queueSize_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "queueSize",
      "");
  }
}

FIFOCommunication* FIFOCommunication::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FIFOCommunication (*this, f, c);
}

FIFOCommunication& FIFOCommunication::
operator= (const FIFOCommunication& x)
{
  if (this != &x)
  {
    static_cast< ::AbstractCommunication& > (*this) = x;
    this->dataSize_ = x.dataSize_;
    this->dataSizeUnit_ = x.dataSizeUnit_;
    this->queueSize_ = x.queueSize_;
  }

  return *this;
}

FIFOCommunication::
~FIFOCommunication ()
{
}

// CommonInstructionSet
//

CommonInstructionSet::
CommonInstructionSet (const name_type& name)
: ::xml_schema::type (),
  Instruction_ (this),
  name_ (name, this)
{
}

CommonInstructionSet::
CommonInstructionSet (const CommonInstructionSet& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Instruction_ (x.Instruction_, f, this),
  name_ (x.name_, f, this)
{
}

CommonInstructionSet::
CommonInstructionSet (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Instruction_ (this),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void CommonInstructionSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Instruction
    //
    if (n.name () == "Instruction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Instruction_type > r (
        Instruction_traits::create (i, f, this));

      this->Instruction_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

CommonInstructionSet* CommonInstructionSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CommonInstructionSet (*this, f, c);
}

CommonInstructionSet& CommonInstructionSet::
operator= (const CommonInstructionSet& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Instruction_ = x.Instruction_;
    this->name_ = x.name_;
  }

  return *this;
}

CommonInstructionSet::
~CommonInstructionSet ()
{
}

// Cache
//

Cache::
Cache (const name_type& name,
       const id_type& id,
       const cacheType_type& cacheType,
       const cacheCoherency_type& cacheCoherency,
       const size_type& size,
       const sizeUnit_type& sizeUnit)
: ::xml_schema::type (),
  cacheRef_ (this),
  name_ (name, this),
  id_ (id, this),
  cacheType_ (cacheType, this),
  cacheCoherency_ (cacheCoherency, this),
  size_ (size, this),
  sizeUnit_ (sizeUnit, this),
  nWay_ (this),
  lineSize_ (this),
  lockDownType_ (this)
{
}

Cache::
Cache (const Cache& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  cacheRef_ (x.cacheRef_, f, this),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  cacheType_ (x.cacheType_, f, this),
  cacheCoherency_ (x.cacheCoherency_, f, this),
  size_ (x.size_, f, this),
  sizeUnit_ (x.sizeUnit_, f, this),
  nWay_ (x.nWay_, f, this),
  lineSize_ (x.lineSize_, f, this),
  lockDownType_ (x.lockDownType_, f, this)
{
}

Cache::
Cache (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  cacheRef_ (this),
  name_ (this),
  id_ (this),
  cacheType_ (this),
  cacheCoherency_ (this),
  size_ (this),
  sizeUnit_ (this),
  nWay_ (this),
  lineSize_ (this),
  lockDownType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Cache::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cacheRef
    //
    if (n.name () == "cacheRef" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cacheRef_type > r (
        cacheRef_traits::create (i, f, this));

      this->cacheRef_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "cacheType" && n.namespace_ ().empty ())
    {
      this->cacheType_.set (cacheType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "cacheCoherency" && n.namespace_ ().empty ())
    {
      this->cacheCoherency_.set (cacheCoherency_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "size" && n.namespace_ ().empty ())
    {
      this->size_.set (size_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sizeUnit" && n.namespace_ ().empty ())
    {
      this->sizeUnit_.set (sizeUnit_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "nWay" && n.namespace_ ().empty ())
    {
      this->nWay_.set (nWay_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lineSize" && n.namespace_ ().empty ())
    {
      this->lineSize_.set (lineSize_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lockDownType" && n.namespace_ ().empty ())
    {
      this->lockDownType_.set (lockDownType_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!cacheType_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "cacheType",
      "");
  }

  if (!cacheCoherency_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "cacheCoherency",
      "");
  }

  if (!size_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "size",
      "");
  }

  if (!sizeUnit_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sizeUnit",
      "");
  }
}

Cache* Cache::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Cache (*this, f, c);
}

Cache& Cache::
operator= (const Cache& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->cacheRef_ = x.cacheRef_;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->cacheType_ = x.cacheType_;
    this->cacheCoherency_ = x.cacheCoherency_;
    this->size_ = x.size_;
    this->sizeUnit_ = x.sizeUnit_;
    this->nWay_ = x.nWay_;
    this->lineSize_ = x.lineSize_;
    this->lockDownType_ = x.lockDownType_;
  }

  return *this;
}

Cache::
~Cache ()
{
}

// SystemConfiguration
//

SystemConfiguration::
SystemConfiguration (const ComponentSet_type& ComponentSet,
                     const ClockFrequency_type& ClockFrequency,
                     const name_type& name,
                     const shimVersion_type& shimVersion)
: ::xml_schema::type (),
  ComponentSet_ (ComponentSet, this),
  CommunicationSet_ (this),
  AddressSpaceSet_ (this),
  ClockFrequency_ (ClockFrequency, this),
  name_ (name, this),
  shimVersion_ (shimVersion, this)
{
}

SystemConfiguration::
SystemConfiguration (::std::auto_ptr< ComponentSet_type > ComponentSet,
                     ::std::auto_ptr< ClockFrequency_type > ClockFrequency,
                     const name_type& name,
                     const shimVersion_type& shimVersion)
: ::xml_schema::type (),
  ComponentSet_ (ComponentSet, this),
  CommunicationSet_ (this),
  AddressSpaceSet_ (this),
  ClockFrequency_ (ClockFrequency, this),
  name_ (name, this),
  shimVersion_ (shimVersion, this)
{
}

SystemConfiguration::
SystemConfiguration (const SystemConfiguration& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ComponentSet_ (x.ComponentSet_, f, this),
  CommunicationSet_ (x.CommunicationSet_, f, this),
  AddressSpaceSet_ (x.AddressSpaceSet_, f, this),
  ClockFrequency_ (x.ClockFrequency_, f, this),
  name_ (x.name_, f, this),
  shimVersion_ (x.shimVersion_, f, this)
{
}

SystemConfiguration::
SystemConfiguration (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ComponentSet_ (this),
  CommunicationSet_ (this),
  AddressSpaceSet_ (this),
  ClockFrequency_ (this),
  name_ (this),
  shimVersion_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void SystemConfiguration::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ComponentSet
    //
    if (n.name () == "ComponentSet" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ComponentSet_type > r (
        ComponentSet_traits::create (i, f, this));

      if (!ComponentSet_.present ())
      {
        this->ComponentSet_.set (r);
        continue;
      }
    }

    // CommunicationSet
    //
    if (n.name () == "CommunicationSet" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CommunicationSet_type > r (
        CommunicationSet_traits::create (i, f, this));

      if (!this->CommunicationSet_)
      {
        this->CommunicationSet_.set (r);
        continue;
      }
    }

    // AddressSpaceSet
    //
    if (n.name () == "AddressSpaceSet" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AddressSpaceSet_type > r (
        AddressSpaceSet_traits::create (i, f, this));

      if (!this->AddressSpaceSet_)
      {
        this->AddressSpaceSet_.set (r);
        continue;
      }
    }

    // ClockFrequency
    //
    if (n.name () == "ClockFrequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ClockFrequency_type > r (
        ClockFrequency_traits::create (i, f, this));

      if (!ClockFrequency_.present ())
      {
        this->ClockFrequency_.set (r);
        continue;
      }
    }

    break;
  }

  if (!ComponentSet_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ComponentSet",
      "");
  }

  if (!ClockFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ClockFrequency",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "shimVersion" && n.namespace_ ().empty ())
    {
      this->shimVersion_.set (shimVersion_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!shimVersion_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "shimVersion",
      "");
  }
}

SystemConfiguration* SystemConfiguration::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SystemConfiguration (*this, f, c);
}

SystemConfiguration& SystemConfiguration::
operator= (const SystemConfiguration& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ComponentSet_ = x.ComponentSet_;
    this->CommunicationSet_ = x.CommunicationSet_;
    this->AddressSpaceSet_ = x.AddressSpaceSet_;
    this->ClockFrequency_ = x.ClockFrequency_;
    this->name_ = x.name_;
    this->shimVersion_ = x.shimVersion_;
  }

  return *this;
}

SystemConfiguration::
~SystemConfiguration ()
{
}

// ConnectionSet
//

ConnectionSet::
ConnectionSet ()
: ::xml_schema::type (),
  Connection_ (this)
{
}

ConnectionSet::
ConnectionSet (const ConnectionSet& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Connection_ (x.Connection_, f, this)
{
}

ConnectionSet::
ConnectionSet (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Connection_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ConnectionSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Connection
    //
    if (n.name () == "Connection" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Connection_type > r (
        Connection_traits::create (i, f, this));

      this->Connection_.push_back (r);
      continue;
    }

    break;
  }
}

ConnectionSet* ConnectionSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ConnectionSet (*this, f, c);
}

ConnectionSet& ConnectionSet::
operator= (const ConnectionSet& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Connection_ = x.Connection_;
  }

  return *this;
}

ConnectionSet::
~ConnectionSet ()
{
}

// CacheCoherencyType
//

CacheCoherencyType::
CacheCoherencyType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_CacheCoherencyType_convert ();
}

CacheCoherencyType::
CacheCoherencyType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_CacheCoherencyType_convert ();
}

CacheCoherencyType::
CacheCoherencyType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_CacheCoherencyType_convert ();
}

CacheCoherencyType* CacheCoherencyType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CacheCoherencyType (*this, f, c);
}

CacheCoherencyType::value CacheCoherencyType::
_xsd_CacheCoherencyType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CacheCoherencyType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_CacheCoherencyType_indexes_,
                    _xsd_CacheCoherencyType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_CacheCoherencyType_indexes_ + 2 || _xsd_CacheCoherencyType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const CacheCoherencyType::
_xsd_CacheCoherencyType_literals_[2] =
{
  "SOFT",
  "HARD"
};

const CacheCoherencyType::value CacheCoherencyType::
_xsd_CacheCoherencyType_indexes_[2] =
{
  ::CacheCoherencyType::HARD,
  ::CacheCoherencyType::SOFT
};

// MemoryConsistencyModel
//

MemoryConsistencyModel::
MemoryConsistencyModel ()
: ::xml_schema::type (),
  rawOrdering_ (this),
  warOrdering_ (this),
  wawOrdering_ (this),
  rarOrdering_ (this)
{
}

MemoryConsistencyModel::
MemoryConsistencyModel (const MemoryConsistencyModel& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  rawOrdering_ (x.rawOrdering_, f, this),
  warOrdering_ (x.warOrdering_, f, this),
  wawOrdering_ (x.wawOrdering_, f, this),
  rarOrdering_ (x.rarOrdering_, f, this)
{
}

MemoryConsistencyModel::
MemoryConsistencyModel (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  rawOrdering_ (this),
  warOrdering_ (this),
  wawOrdering_ (this),
  rarOrdering_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void MemoryConsistencyModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "rawOrdering" && n.namespace_ ().empty ())
    {
      this->rawOrdering_.set (rawOrdering_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "warOrdering" && n.namespace_ ().empty ())
    {
      this->warOrdering_.set (warOrdering_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "wawOrdering" && n.namespace_ ().empty ())
    {
      this->wawOrdering_.set (wawOrdering_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rarOrdering" && n.namespace_ ().empty ())
    {
      this->rarOrdering_.set (rarOrdering_traits::create (i, f, this));
      continue;
    }
  }
}

MemoryConsistencyModel* MemoryConsistencyModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MemoryConsistencyModel (*this, f, c);
}

MemoryConsistencyModel& MemoryConsistencyModel::
operator= (const MemoryConsistencyModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->rawOrdering_ = x.rawOrdering_;
    this->warOrdering_ = x.warOrdering_;
    this->wawOrdering_ = x.wawOrdering_;
    this->rarOrdering_ = x.rarOrdering_;
  }

  return *this;
}

MemoryConsistencyModel::
~MemoryConsistencyModel ()
{
}

// OrderingType
//

OrderingType::
OrderingType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_OrderingType_convert ();
}

OrderingType::
OrderingType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_OrderingType_convert ();
}

OrderingType::
OrderingType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_OrderingType_convert ();
}

OrderingType* OrderingType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OrderingType (*this, f, c);
}

OrderingType::value OrderingType::
_xsd_OrderingType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_OrderingType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_OrderingType_indexes_,
                    _xsd_OrderingType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_OrderingType_indexes_ + 2 || _xsd_OrderingType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const OrderingType::
_xsd_OrderingType_literals_[2] =
{
  "ORDERD",
  "UNORDERD"
};

const OrderingType::value OrderingType::
_xsd_OrderingType_indexes_[2] =
{
  ::OrderingType::ORDERD,
  ::OrderingType::UNORDERD
};

// EndianType
//

EndianType::
EndianType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_EndianType_convert ();
}

EndianType::
EndianType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_EndianType_convert ();
}

EndianType::
EndianType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_EndianType_convert ();
}

EndianType* EndianType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EndianType (*this, f, c);
}

EndianType::value EndianType::
_xsd_EndianType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_EndianType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_EndianType_indexes_,
                    _xsd_EndianType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_EndianType_indexes_ + 2 || _xsd_EndianType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const EndianType::
_xsd_EndianType_literals_[2] =
{
  "LITTLE",
  "BIG"
};

const EndianType::value EndianType::
_xsd_EndianType_indexes_[2] =
{
  ::EndianType::BIG,
  ::EndianType::LITTLE
};

// SharedRegisterCommunication
//

SharedRegisterCommunication::
SharedRegisterCommunication (const name_type& name,
                             const dataSize_type& dataSize,
                             const dataSizeUnit_type& dataSizeUnit,
                             const nRegister_type& nRegister)
: ::AbstractCommunication (name),
  dataSize_ (dataSize, this),
  dataSizeUnit_ (dataSizeUnit, this),
  nRegister_ (nRegister, this)
{
}

SharedRegisterCommunication::
SharedRegisterCommunication (const SharedRegisterCommunication& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::AbstractCommunication (x, f, c),
  dataSize_ (x.dataSize_, f, this),
  dataSizeUnit_ (x.dataSizeUnit_, f, this),
  nRegister_ (x.nRegister_, f, this)
{
}

SharedRegisterCommunication::
SharedRegisterCommunication (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::AbstractCommunication (e, f | ::xml_schema::flags::base, c),
  dataSize_ (this),
  dataSizeUnit_ (this),
  nRegister_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void SharedRegisterCommunication::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::AbstractCommunication::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "dataSize" && n.namespace_ ().empty ())
    {
      this->dataSize_.set (dataSize_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dataSizeUnit" && n.namespace_ ().empty ())
    {
      this->dataSizeUnit_.set (dataSizeUnit_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "nRegister" && n.namespace_ ().empty ())
    {
      this->nRegister_.set (nRegister_traits::create (i, f, this));
      continue;
    }
  }

  if (!dataSize_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dataSize",
      "");
  }

  if (!dataSizeUnit_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dataSizeUnit",
      "");
  }

  if (!nRegister_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "nRegister",
      "");
  }
}

SharedRegisterCommunication* SharedRegisterCommunication::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SharedRegisterCommunication (*this, f, c);
}

SharedRegisterCommunication& SharedRegisterCommunication::
operator= (const SharedRegisterCommunication& x)
{
  if (this != &x)
  {
    static_cast< ::AbstractCommunication& > (*this) = x;
    this->dataSize_ = x.dataSize_;
    this->dataSizeUnit_ = x.dataSizeUnit_;
    this->nRegister_ = x.nRegister_;
  }

  return *this;
}

SharedRegisterCommunication::
~SharedRegisterCommunication ()
{
}

// SharedMemoryCommunication
//

SharedMemoryCommunication::
SharedMemoryCommunication (const name_type& name)
: ::AbstractCommunication (name),
  operationType_ (this),
  dataSize_ (this),
  dataSizeUnit_ (this),
  addressSpaceRef_ (this),
  subSpaceRef_ (this)
{
}

SharedMemoryCommunication::
SharedMemoryCommunication (const SharedMemoryCommunication& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::AbstractCommunication (x, f, c),
  operationType_ (x.operationType_, f, this),
  dataSize_ (x.dataSize_, f, this),
  dataSizeUnit_ (x.dataSizeUnit_, f, this),
  addressSpaceRef_ (x.addressSpaceRef_, f, this),
  subSpaceRef_ (x.subSpaceRef_, f, this)
{
}

SharedMemoryCommunication::
SharedMemoryCommunication (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::AbstractCommunication (e, f | ::xml_schema::flags::base, c),
  operationType_ (this),
  dataSize_ (this),
  dataSizeUnit_ (this),
  addressSpaceRef_ (this),
  subSpaceRef_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void SharedMemoryCommunication::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::AbstractCommunication::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "operationType" && n.namespace_ ().empty ())
    {
      this->operationType_.set (operationType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dataSize" && n.namespace_ ().empty ())
    {
      this->dataSize_.set (dataSize_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dataSizeUnit" && n.namespace_ ().empty ())
    {
      this->dataSizeUnit_.set (dataSizeUnit_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "addressSpaceRef" && n.namespace_ ().empty ())
    {
      this->addressSpaceRef_.set (addressSpaceRef_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "subSpaceRef" && n.namespace_ ().empty ())
    {
      this->subSpaceRef_.set (subSpaceRef_traits::create (i, f, this));
      continue;
    }
  }
}

SharedMemoryCommunication* SharedMemoryCommunication::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SharedMemoryCommunication (*this, f, c);
}

SharedMemoryCommunication& SharedMemoryCommunication::
operator= (const SharedMemoryCommunication& x)
{
  if (this != &x)
  {
    static_cast< ::AbstractCommunication& > (*this) = x;
    this->operationType_ = x.operationType_;
    this->dataSize_ = x.dataSize_;
    this->dataSizeUnit_ = x.dataSizeUnit_;
    this->addressSpaceRef_ = x.addressSpaceRef_;
    this->subSpaceRef_ = x.subSpaceRef_;
  }

  return *this;
}

SharedMemoryCommunication::
~SharedMemoryCommunication ()
{
}

// EventCommunication
//

EventCommunication::
EventCommunication (const name_type& name)
: ::AbstractCommunication (name)
{
}

EventCommunication::
EventCommunication (const EventCommunication& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::AbstractCommunication (x, f, c)
{
}

EventCommunication::
EventCommunication (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::AbstractCommunication (e, f, c)
{
}

EventCommunication* EventCommunication::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EventCommunication (*this, f, c);
}

EventCommunication::
~EventCommunication ()
{
}

// ClockFrequency
//

ClockFrequency::
ClockFrequency (const clockValue_type& clockValue)
: ::xml_schema::type (),
  clockValue_ (clockValue, this)
{
}

ClockFrequency::
ClockFrequency (const ClockFrequency& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  clockValue_ (x.clockValue_, f, this)
{
}

ClockFrequency::
ClockFrequency (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  clockValue_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ClockFrequency::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "clockValue" && n.namespace_ ().empty ())
    {
      this->clockValue_.set (clockValue_traits::create (i, f, this));
      continue;
    }
  }

  if (!clockValue_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "clockValue",
      "");
  }
}

ClockFrequency* ClockFrequency::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ClockFrequency (*this, f, c);
}

ClockFrequency& ClockFrequency::
operator= (const ClockFrequency& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->clockValue_ = x.clockValue_;
  }

  return *this;
}

ClockFrequency::
~ClockFrequency ()
{
}

// Accessor
//

Accessor::
Accessor (const masterComponentRef_type& masterComponentRef)
: ::xml_schema::type (),
  PerformanceSet_ (this),
  masterComponentRef_ (masterComponentRef, this)
{
}

Accessor::
Accessor (const Accessor& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  PerformanceSet_ (x.PerformanceSet_, f, this),
  masterComponentRef_ (x.masterComponentRef_, f, this)
{
}

Accessor::
Accessor (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  PerformanceSet_ (this),
  masterComponentRef_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Accessor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // PerformanceSet
    //
    if (n.name () == "PerformanceSet" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PerformanceSet_type > r (
        PerformanceSet_traits::create (i, f, this));

      this->PerformanceSet_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "masterComponentRef" && n.namespace_ ().empty ())
    {
      this->masterComponentRef_.set (masterComponentRef_traits::create (i, f, this));
      continue;
    }
  }

  if (!masterComponentRef_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "masterComponentRef",
      "");
  }
}

Accessor* Accessor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Accessor (*this, f, c);
}

Accessor& Accessor::
operator= (const Accessor& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->PerformanceSet_ = x.PerformanceSet_;
    this->masterComponentRef_ = x.masterComponentRef_;
  }

  return *this;
}

Accessor::
~Accessor ()
{
}

// AccessType
//

AccessType::
AccessType (const name_type& name,
            const id_type& id)
: ::xml_schema::type (),
  name_ (name, this),
  id_ (id, this),
  rwType_ (this),
  accessByteSize_ (this),
  alignmentByteSize_ (this),
  nBurst_ (this)
{
}

AccessType::
AccessType (const AccessType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  id_ (x.id_, f, this),
  rwType_ (x.rwType_, f, this),
  accessByteSize_ (x.accessByteSize_, f, this),
  alignmentByteSize_ (x.alignmentByteSize_, f, this),
  nBurst_ (x.nBurst_, f, this)
{
}

AccessType::
AccessType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  id_ (this),
  rwType_ (this),
  accessByteSize_ (this),
  alignmentByteSize_ (this),
  nBurst_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void AccessType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      this->name_.set (name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rwType" && n.namespace_ ().empty ())
    {
      this->rwType_.set (rwType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "accessByteSize" && n.namespace_ ().empty ())
    {
      this->accessByteSize_.set (accessByteSize_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "alignmentByteSize" && n.namespace_ ().empty ())
    {
      this->alignmentByteSize_.set (alignmentByteSize_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "nBurst" && n.namespace_ ().empty ())
    {
      this->nBurst_.set (nBurst_traits::create (i, f, this));
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

AccessType* AccessType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AccessType (*this, f, c);
}

AccessType& AccessType::
operator= (const AccessType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->id_ = x.id_;
    this->rwType_ = x.rwType_;
    this->accessByteSize_ = x.accessByteSize_;
    this->alignmentByteSize_ = x.alignmentByteSize_;
    this->nBurst_ = x.nBurst_;
  }

  return *this;
}

AccessType::
~AccessType ()
{
}

// MasterSlaveBindingSet
//

MasterSlaveBindingSet::
MasterSlaveBindingSet ()
: ::xml_schema::type (),
  MasterSlaveBinding_ (this)
{
}

MasterSlaveBindingSet::
MasterSlaveBindingSet (const MasterSlaveBindingSet& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  MasterSlaveBinding_ (x.MasterSlaveBinding_, f, this)
{
}

MasterSlaveBindingSet::
MasterSlaveBindingSet (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  MasterSlaveBinding_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MasterSlaveBindingSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // MasterSlaveBinding
    //
    if (n.name () == "MasterSlaveBinding" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MasterSlaveBinding_type > r (
        MasterSlaveBinding_traits::create (i, f, this));

      this->MasterSlaveBinding_.push_back (r);
      continue;
    }

    break;
  }
}

MasterSlaveBindingSet* MasterSlaveBindingSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MasterSlaveBindingSet (*this, f, c);
}

MasterSlaveBindingSet& MasterSlaveBindingSet::
operator= (const MasterSlaveBindingSet& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->MasterSlaveBinding_ = x.MasterSlaveBinding_;
  }

  return *this;
}

MasterSlaveBindingSet::
~MasterSlaveBindingSet ()
{
}

// CacheType
//

CacheType::
CacheType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_CacheType_convert ();
}

CacheType::
CacheType (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_CacheType_convert ();
}

CacheType::
CacheType (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_CacheType_convert ();
}

CacheType* CacheType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CacheType (*this, f, c);
}

CacheType::value CacheType::
_xsd_CacheType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CacheType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_CacheType_indexes_,
                    _xsd_CacheType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_CacheType_indexes_ + 3 || _xsd_CacheType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const CacheType::
_xsd_CacheType_literals_[3] =
{
  "DATA",
  "INSTRUCTION",
  "UNIFIED"
};

const CacheType::value CacheType::
_xsd_CacheType_indexes_[3] =
{
  ::CacheType::DATA,
  ::CacheType::INSTRUCTION,
  ::CacheType::UNIFIED
};

// Performance
//

Performance::
Performance (const Pitch_type& Pitch,
             const Latency_type& Latency)
: ::xml_schema::type (),
  Pitch_ (Pitch, this),
  Latency_ (Latency, this),
  accessTypeRef_ (this)
{
}

Performance::
Performance (::std::auto_ptr< Pitch_type > Pitch,
             ::std::auto_ptr< Latency_type > Latency)
: ::xml_schema::type (),
  Pitch_ (Pitch, this),
  Latency_ (Latency, this),
  accessTypeRef_ (this)
{
}

Performance::
Performance (const Performance& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Pitch_ (x.Pitch_, f, this),
  Latency_ (x.Latency_, f, this),
  accessTypeRef_ (x.accessTypeRef_, f, this)
{
}

Performance::
Performance (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Pitch_ (this),
  Latency_ (this),
  accessTypeRef_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Performance::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Pitch
    //
    if (n.name () == "Pitch" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Pitch_type > r (
        Pitch_traits::create (i, f, this));

      if (!Pitch_.present ())
      {
        this->Pitch_.set (r);
        continue;
      }
    }

    // Latency
    //
    if (n.name () == "Latency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Latency_type > r (
        Latency_traits::create (i, f, this));

      if (!Latency_.present ())
      {
        this->Latency_.set (r);
        continue;
      }
    }

    break;
  }

  if (!Pitch_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pitch",
      "");
  }

  if (!Latency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Latency",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "accessTypeRef" && n.namespace_ ().empty ())
    {
      this->accessTypeRef_.set (accessTypeRef_traits::create (i, f, this));
      continue;
    }
  }
}

Performance* Performance::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Performance (*this, f, c);
}

Performance& Performance::
operator= (const Performance& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Pitch_ = x.Pitch_;
    this->Latency_ = x.Latency_;
    this->accessTypeRef_ = x.accessTypeRef_;
  }

  return *this;
}

Performance::
~Performance ()
{
}

// AccessTypeSet
//

AccessTypeSet::
AccessTypeSet ()
: ::xml_schema::type (),
  AccessType_ (this)
{
}

AccessTypeSet::
AccessTypeSet (const AccessTypeSet& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  AccessType_ (x.AccessType_, f, this)
{
}

AccessTypeSet::
AccessTypeSet (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  AccessType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void AccessTypeSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AccessType
    //
    if (n.name () == "AccessType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AccessType_type > r (
        AccessType_traits::create (i, f, this));

      this->AccessType_.push_back (r);
      continue;
    }

    break;
  }
}

AccessTypeSet* AccessTypeSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AccessTypeSet (*this, f, c);
}

AccessTypeSet& AccessTypeSet::
operator= (const AccessTypeSet& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->AccessType_ = x.AccessType_;
  }

  return *this;
}

AccessTypeSet::
~AccessTypeSet ()
{
}

// SizeUnitType
//

SizeUnitType::
SizeUnitType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_SizeUnitType_convert ();
}

SizeUnitType::
SizeUnitType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_SizeUnitType_convert ();
}

SizeUnitType::
SizeUnitType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_SizeUnitType_convert ();
}

SizeUnitType* SizeUnitType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SizeUnitType (*this, f, c);
}

SizeUnitType::value SizeUnitType::
_xsd_SizeUnitType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SizeUnitType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_SizeUnitType_indexes_,
                    _xsd_SizeUnitType_indexes_ + 5,
                    *this,
                    c));

  if (i == _xsd_SizeUnitType_indexes_ + 5 || _xsd_SizeUnitType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const SizeUnitType::
_xsd_SizeUnitType_literals_[5] =
{
  "KiB",
  "B",
  "GiB",
  "MiB",
  "TiB"
};

const SizeUnitType::value SizeUnitType::
_xsd_SizeUnitType_indexes_[5] =
{
  ::SizeUnitType::B,
  ::SizeUnitType::GiB,
  ::SizeUnitType::KiB,
  ::SizeUnitType::MiB,
  ::SizeUnitType::TiB
};

// LockDownType
//

LockDownType::
LockDownType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_LockDownType_convert ();
}

LockDownType::
LockDownType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_LockDownType_convert ();
}

LockDownType::
LockDownType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_LockDownType_convert ();
}

LockDownType* LockDownType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LockDownType (*this, f, c);
}

LockDownType::value LockDownType::
_xsd_LockDownType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_LockDownType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_LockDownType_indexes_,
                    _xsd_LockDownType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_LockDownType_indexes_ + 3 || _xsd_LockDownType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const LockDownType::
_xsd_LockDownType_literals_[3] =
{
  "LINE",
  "NONE",
  "WAY"
};

const LockDownType::value LockDownType::
_xsd_LockDownType_indexes_[3] =
{
  ::LockDownType::LINE,
  ::LockDownType::NONE,
  ::LockDownType::WAY
};

// OperationType
//

OperationType::
OperationType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_OperationType_convert ();
}

OperationType::
OperationType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_OperationType_convert ();
}

OperationType::
OperationType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_OperationType_convert ();
}

OperationType* OperationType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OperationType (*this, f, c);
}

OperationType::value OperationType::
_xsd_OperationType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_OperationType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_OperationType_indexes_,
                    _xsd_OperationType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_OperationType_indexes_ + 4 || _xsd_OperationType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const OperationType::
_xsd_OperationType_literals_[4] =
{
  "TAS",
  "LLSC",
  "CAX",
  "OTHER"
};

const OperationType::value OperationType::
_xsd_OperationType_indexes_[4] =
{
  ::OperationType::CAX,
  ::OperationType::LLSC,
  ::OperationType::OTHER,
  ::OperationType::TAS
};

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::ComponentSet >
ComponentSet_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::ComponentSet > (
    ::ComponentSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ComponentSet >
ComponentSet_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ComponentSet > (
    ::ComponentSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ComponentSet >
ComponentSet_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ComponentSet > (
    ::ComponentSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ComponentSet >
ComponentSet_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ComponentSet_ (isrc, f, p);
}

::std::auto_ptr< ::ComponentSet >
ComponentSet_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ComponentSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::ComponentSet >
ComponentSet_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ComponentSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::ComponentSet >
ComponentSet_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ComponentSet_ (isrc, f, p);
}

::std::auto_ptr< ::ComponentSet >
ComponentSet_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ComponentSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::ComponentSet >
ComponentSet_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ComponentSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::ComponentSet >
ComponentSet_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::ComponentSet > (
    ::ComponentSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ComponentSet >
ComponentSet_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ComponentSet > (
    ::ComponentSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ComponentSet >
ComponentSet_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ComponentSet > (
    ::ComponentSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ComponentSet >
ComponentSet_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::ComponentSet > (
      ::ComponentSet_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "ComponentSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::ComponentSet > r (
      ::xsd::cxx::tree::traits< ::ComponentSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "ComponentSet",
    "");
}

::std::auto_ptr< ::ComponentSet >
ComponentSet_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "ComponentSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::ComponentSet > r (
      ::xsd::cxx::tree::traits< ::ComponentSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "ComponentSet",
    "");
}

::std::auto_ptr< ::SlaveComponent >
SlaveComponent_ (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::SlaveComponent > (
    ::SlaveComponent_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SlaveComponent >
SlaveComponent_ (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SlaveComponent > (
    ::SlaveComponent_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SlaveComponent >
SlaveComponent_ (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SlaveComponent > (
    ::SlaveComponent_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SlaveComponent >
SlaveComponent_ (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SlaveComponent_ (isrc, f, p);
}

::std::auto_ptr< ::SlaveComponent >
SlaveComponent_ (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SlaveComponent_ (isrc, h, f, p);
}

::std::auto_ptr< ::SlaveComponent >
SlaveComponent_ (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SlaveComponent_ (isrc, h, f, p);
}

::std::auto_ptr< ::SlaveComponent >
SlaveComponent_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SlaveComponent_ (isrc, f, p);
}

::std::auto_ptr< ::SlaveComponent >
SlaveComponent_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SlaveComponent_ (isrc, h, f, p);
}

::std::auto_ptr< ::SlaveComponent >
SlaveComponent_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SlaveComponent_ (isrc, h, f, p);
}

::std::auto_ptr< ::SlaveComponent >
SlaveComponent_ (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::SlaveComponent > (
    ::SlaveComponent_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SlaveComponent >
SlaveComponent_ (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SlaveComponent > (
    ::SlaveComponent_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SlaveComponent >
SlaveComponent_ (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SlaveComponent > (
    ::SlaveComponent_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SlaveComponent >
SlaveComponent_ (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::SlaveComponent > (
      ::SlaveComponent_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "SlaveComponent" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SlaveComponent > r (
      ::xsd::cxx::tree::traits< ::SlaveComponent, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "SlaveComponent",
    "");
}

::std::auto_ptr< ::SlaveComponent >
SlaveComponent_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "SlaveComponent" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SlaveComponent > r (
      ::xsd::cxx::tree::traits< ::SlaveComponent, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "SlaveComponent",
    "");
}

::std::auto_ptr< ::MasterComponent >
MasterComponent_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::MasterComponent > (
    ::MasterComponent_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterComponent >
MasterComponent_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MasterComponent > (
    ::MasterComponent_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterComponent >
MasterComponent_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MasterComponent > (
    ::MasterComponent_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterComponent >
MasterComponent_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MasterComponent_ (isrc, f, p);
}

::std::auto_ptr< ::MasterComponent >
MasterComponent_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MasterComponent_ (isrc, h, f, p);
}

::std::auto_ptr< ::MasterComponent >
MasterComponent_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MasterComponent_ (isrc, h, f, p);
}

::std::auto_ptr< ::MasterComponent >
MasterComponent_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MasterComponent_ (isrc, f, p);
}

::std::auto_ptr< ::MasterComponent >
MasterComponent_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MasterComponent_ (isrc, h, f, p);
}

::std::auto_ptr< ::MasterComponent >
MasterComponent_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MasterComponent_ (isrc, h, f, p);
}

::std::auto_ptr< ::MasterComponent >
MasterComponent_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::MasterComponent > (
    ::MasterComponent_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterComponent >
MasterComponent_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MasterComponent > (
    ::MasterComponent_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterComponent >
MasterComponent_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MasterComponent > (
    ::MasterComponent_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterComponent >
MasterComponent_ (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::MasterComponent > (
      ::MasterComponent_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "MasterComponent" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::MasterComponent > r (
      ::xsd::cxx::tree::traits< ::MasterComponent, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MasterComponent",
    "");
}

::std::auto_ptr< ::MasterComponent >
MasterComponent_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "MasterComponent" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::MasterComponent > r (
      ::xsd::cxx::tree::traits< ::MasterComponent, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MasterComponent",
    "");
}

::std::auto_ptr< ::AddressSpaceSet >
AddressSpaceSet_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::AddressSpaceSet > (
    ::AddressSpaceSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AddressSpaceSet >
AddressSpaceSet_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AddressSpaceSet > (
    ::AddressSpaceSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AddressSpaceSet >
AddressSpaceSet_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AddressSpaceSet > (
    ::AddressSpaceSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AddressSpaceSet >
AddressSpaceSet_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AddressSpaceSet_ (isrc, f, p);
}

::std::auto_ptr< ::AddressSpaceSet >
AddressSpaceSet_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AddressSpaceSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::AddressSpaceSet >
AddressSpaceSet_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AddressSpaceSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::AddressSpaceSet >
AddressSpaceSet_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AddressSpaceSet_ (isrc, f, p);
}

::std::auto_ptr< ::AddressSpaceSet >
AddressSpaceSet_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AddressSpaceSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::AddressSpaceSet >
AddressSpaceSet_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AddressSpaceSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::AddressSpaceSet >
AddressSpaceSet_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::AddressSpaceSet > (
    ::AddressSpaceSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AddressSpaceSet >
AddressSpaceSet_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AddressSpaceSet > (
    ::AddressSpaceSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AddressSpaceSet >
AddressSpaceSet_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AddressSpaceSet > (
    ::AddressSpaceSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AddressSpaceSet >
AddressSpaceSet_ (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::AddressSpaceSet > (
      ::AddressSpaceSet_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "AddressSpaceSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::AddressSpaceSet > r (
      ::xsd::cxx::tree::traits< ::AddressSpaceSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "AddressSpaceSet",
    "");
}

::std::auto_ptr< ::AddressSpaceSet >
AddressSpaceSet_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "AddressSpaceSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::AddressSpaceSet > r (
      ::xsd::cxx::tree::traits< ::AddressSpaceSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "AddressSpaceSet",
    "");
}

::std::auto_ptr< ::AddressSpace >
AddressSpace_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::AddressSpace > (
    ::AddressSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AddressSpace >
AddressSpace_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AddressSpace > (
    ::AddressSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AddressSpace >
AddressSpace_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AddressSpace > (
    ::AddressSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AddressSpace >
AddressSpace_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AddressSpace_ (isrc, f, p);
}

::std::auto_ptr< ::AddressSpace >
AddressSpace_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AddressSpace_ (isrc, h, f, p);
}

::std::auto_ptr< ::AddressSpace >
AddressSpace_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AddressSpace_ (isrc, h, f, p);
}

::std::auto_ptr< ::AddressSpace >
AddressSpace_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AddressSpace_ (isrc, f, p);
}

::std::auto_ptr< ::AddressSpace >
AddressSpace_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AddressSpace_ (isrc, h, f, p);
}

::std::auto_ptr< ::AddressSpace >
AddressSpace_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AddressSpace_ (isrc, h, f, p);
}

::std::auto_ptr< ::AddressSpace >
AddressSpace_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::AddressSpace > (
    ::AddressSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AddressSpace >
AddressSpace_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AddressSpace > (
    ::AddressSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AddressSpace >
AddressSpace_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AddressSpace > (
    ::AddressSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AddressSpace >
AddressSpace_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::AddressSpace > (
      ::AddressSpace_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "AddressSpace" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::AddressSpace > r (
      ::xsd::cxx::tree::traits< ::AddressSpace, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "AddressSpace",
    "");
}

::std::auto_ptr< ::AddressSpace >
AddressSpace_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "AddressSpace" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::AddressSpace > r (
      ::xsd::cxx::tree::traits< ::AddressSpace, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "AddressSpace",
    "");
}

::std::auto_ptr< ::SubSpace >
SubSpace_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::SubSpace > (
    ::SubSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SubSpace >
SubSpace_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SubSpace > (
    ::SubSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SubSpace >
SubSpace_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SubSpace > (
    ::SubSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SubSpace >
SubSpace_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SubSpace_ (isrc, f, p);
}

::std::auto_ptr< ::SubSpace >
SubSpace_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SubSpace_ (isrc, h, f, p);
}

::std::auto_ptr< ::SubSpace >
SubSpace_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SubSpace_ (isrc, h, f, p);
}

::std::auto_ptr< ::SubSpace >
SubSpace_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SubSpace_ (isrc, f, p);
}

::std::auto_ptr< ::SubSpace >
SubSpace_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SubSpace_ (isrc, h, f, p);
}

::std::auto_ptr< ::SubSpace >
SubSpace_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SubSpace_ (isrc, h, f, p);
}

::std::auto_ptr< ::SubSpace >
SubSpace_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::SubSpace > (
    ::SubSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SubSpace >
SubSpace_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SubSpace > (
    ::SubSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SubSpace >
SubSpace_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SubSpace > (
    ::SubSpace_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SubSpace >
SubSpace_ (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::SubSpace > (
      ::SubSpace_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "SubSpace" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SubSpace > r (
      ::xsd::cxx::tree::traits< ::SubSpace, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "SubSpace",
    "");
}

::std::auto_ptr< ::SubSpace >
SubSpace_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "SubSpace" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SubSpace > r (
      ::xsd::cxx::tree::traits< ::SubSpace, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "SubSpace",
    "");
}

::std::auto_ptr< ::Instruction >
Instruction_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::Instruction > (
    ::Instruction_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Instruction >
Instruction_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Instruction > (
    ::Instruction_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Instruction >
Instruction_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Instruction > (
    ::Instruction_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Instruction >
Instruction_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Instruction_ (isrc, f, p);
}

::std::auto_ptr< ::Instruction >
Instruction_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Instruction_ (isrc, h, f, p);
}

::std::auto_ptr< ::Instruction >
Instruction_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Instruction_ (isrc, h, f, p);
}

::std::auto_ptr< ::Instruction >
Instruction_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Instruction_ (isrc, f, p);
}

::std::auto_ptr< ::Instruction >
Instruction_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Instruction_ (isrc, h, f, p);
}

::std::auto_ptr< ::Instruction >
Instruction_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Instruction_ (isrc, h, f, p);
}

::std::auto_ptr< ::Instruction >
Instruction_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::Instruction > (
    ::Instruction_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Instruction >
Instruction_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Instruction > (
    ::Instruction_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Instruction >
Instruction_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Instruction > (
    ::Instruction_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Instruction >
Instruction_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::Instruction > (
      ::Instruction_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Instruction" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Instruction > r (
      ::xsd::cxx::tree::traits< ::Instruction, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Instruction",
    "");
}

::std::auto_ptr< ::Instruction >
Instruction_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Instruction" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Instruction > r (
      ::xsd::cxx::tree::traits< ::Instruction, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Instruction",
    "");
}

::std::auto_ptr< ::InterruptCommunication >
InterruptCommunication_ (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::InterruptCommunication > (
    ::InterruptCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::InterruptCommunication >
InterruptCommunication_ (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::InterruptCommunication > (
    ::InterruptCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::InterruptCommunication >
InterruptCommunication_ (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::InterruptCommunication > (
    ::InterruptCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::InterruptCommunication >
InterruptCommunication_ (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::InterruptCommunication_ (isrc, f, p);
}

::std::auto_ptr< ::InterruptCommunication >
InterruptCommunication_ (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::InterruptCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::InterruptCommunication >
InterruptCommunication_ (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::InterruptCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::InterruptCommunication >
InterruptCommunication_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::InterruptCommunication_ (isrc, f, p);
}

::std::auto_ptr< ::InterruptCommunication >
InterruptCommunication_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::InterruptCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::InterruptCommunication >
InterruptCommunication_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::InterruptCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::InterruptCommunication >
InterruptCommunication_ (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::InterruptCommunication > (
    ::InterruptCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::InterruptCommunication >
InterruptCommunication_ (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::InterruptCommunication > (
    ::InterruptCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::InterruptCommunication >
InterruptCommunication_ (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::InterruptCommunication > (
    ::InterruptCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::InterruptCommunication >
InterruptCommunication_ (const ::xercesc::DOMDocument& doc,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::InterruptCommunication > (
      ::InterruptCommunication_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "InterruptCommunication" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::InterruptCommunication > r (
      ::xsd::cxx::tree::traits< ::InterruptCommunication, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "InterruptCommunication",
    "");
}

::std::auto_ptr< ::InterruptCommunication >
InterruptCommunication_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "InterruptCommunication" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::InterruptCommunication > r (
      ::xsd::cxx::tree::traits< ::InterruptCommunication, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "InterruptCommunication",
    "");
}

::std::auto_ptr< ::Latency >
Latency_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::Latency > (
    ::Latency_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Latency >
Latency_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Latency > (
    ::Latency_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Latency >
Latency_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Latency > (
    ::Latency_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Latency >
Latency_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Latency_ (isrc, f, p);
}

::std::auto_ptr< ::Latency >
Latency_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Latency_ (isrc, h, f, p);
}

::std::auto_ptr< ::Latency >
Latency_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Latency_ (isrc, h, f, p);
}

::std::auto_ptr< ::Latency >
Latency_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Latency_ (isrc, f, p);
}

::std::auto_ptr< ::Latency >
Latency_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Latency_ (isrc, h, f, p);
}

::std::auto_ptr< ::Latency >
Latency_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Latency_ (isrc, h, f, p);
}

::std::auto_ptr< ::Latency >
Latency_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::Latency > (
    ::Latency_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Latency >
Latency_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Latency > (
    ::Latency_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Latency >
Latency_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Latency > (
    ::Latency_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Latency >
Latency_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::Latency > (
      ::Latency_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Latency" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Latency > r (
      ::xsd::cxx::tree::traits< ::Latency, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Latency",
    "");
}

::std::auto_ptr< ::Latency >
Latency_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Latency" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Latency > r (
      ::xsd::cxx::tree::traits< ::Latency, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Latency",
    "");
}

::std::auto_ptr< ::AbstractPerformance >
AbstractPerformance_ (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::AbstractPerformance > (
    ::AbstractPerformance_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AbstractPerformance >
AbstractPerformance_ (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AbstractPerformance > (
    ::AbstractPerformance_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AbstractPerformance >
AbstractPerformance_ (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AbstractPerformance > (
    ::AbstractPerformance_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AbstractPerformance >
AbstractPerformance_ (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AbstractPerformance_ (isrc, f, p);
}

::std::auto_ptr< ::AbstractPerformance >
AbstractPerformance_ (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AbstractPerformance_ (isrc, h, f, p);
}

::std::auto_ptr< ::AbstractPerformance >
AbstractPerformance_ (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AbstractPerformance_ (isrc, h, f, p);
}

::std::auto_ptr< ::AbstractPerformance >
AbstractPerformance_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AbstractPerformance_ (isrc, f, p);
}

::std::auto_ptr< ::AbstractPerformance >
AbstractPerformance_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AbstractPerformance_ (isrc, h, f, p);
}

::std::auto_ptr< ::AbstractPerformance >
AbstractPerformance_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AbstractPerformance_ (isrc, h, f, p);
}

::std::auto_ptr< ::AbstractPerformance >
AbstractPerformance_ (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::AbstractPerformance > (
    ::AbstractPerformance_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AbstractPerformance >
AbstractPerformance_ (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AbstractPerformance > (
    ::AbstractPerformance_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AbstractPerformance >
AbstractPerformance_ (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AbstractPerformance > (
    ::AbstractPerformance_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AbstractPerformance >
AbstractPerformance_ (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::AbstractPerformance > (
      ::AbstractPerformance_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "AbstractPerformance" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::AbstractPerformance > r (
      ::xsd::cxx::tree::traits< ::AbstractPerformance, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "AbstractPerformance",
    "");
}

::std::auto_ptr< ::AbstractPerformance >
AbstractPerformance_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "AbstractPerformance" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::AbstractPerformance > r (
      ::xsd::cxx::tree::traits< ::AbstractPerformance, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "AbstractPerformance",
    "");
}

::std::auto_ptr< ::Pitch >
Pitch_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::Pitch > (
    ::Pitch_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Pitch >
Pitch_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Pitch > (
    ::Pitch_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Pitch >
Pitch_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Pitch > (
    ::Pitch_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Pitch >
Pitch_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Pitch_ (isrc, f, p);
}

::std::auto_ptr< ::Pitch >
Pitch_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Pitch_ (isrc, h, f, p);
}

::std::auto_ptr< ::Pitch >
Pitch_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Pitch_ (isrc, h, f, p);
}

::std::auto_ptr< ::Pitch >
Pitch_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Pitch_ (isrc, f, p);
}

::std::auto_ptr< ::Pitch >
Pitch_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Pitch_ (isrc, h, f, p);
}

::std::auto_ptr< ::Pitch >
Pitch_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Pitch_ (isrc, h, f, p);
}

::std::auto_ptr< ::Pitch >
Pitch_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::Pitch > (
    ::Pitch_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Pitch >
Pitch_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Pitch > (
    ::Pitch_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Pitch >
Pitch_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Pitch > (
    ::Pitch_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Pitch >
Pitch_ (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::Pitch > (
      ::Pitch_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Pitch" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Pitch > r (
      ::xsd::cxx::tree::traits< ::Pitch, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Pitch",
    "");
}

::std::auto_ptr< ::Pitch >
Pitch_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Pitch" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Pitch > r (
      ::xsd::cxx::tree::traits< ::Pitch, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Pitch",
    "");
}

::std::auto_ptr< ::MasterSlaveBinding >
MasterSlaveBinding_ (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::MasterSlaveBinding > (
    ::MasterSlaveBinding_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterSlaveBinding >
MasterSlaveBinding_ (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MasterSlaveBinding > (
    ::MasterSlaveBinding_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterSlaveBinding >
MasterSlaveBinding_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MasterSlaveBinding > (
    ::MasterSlaveBinding_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterSlaveBinding >
MasterSlaveBinding_ (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MasterSlaveBinding_ (isrc, f, p);
}

::std::auto_ptr< ::MasterSlaveBinding >
MasterSlaveBinding_ (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MasterSlaveBinding_ (isrc, h, f, p);
}

::std::auto_ptr< ::MasterSlaveBinding >
MasterSlaveBinding_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MasterSlaveBinding_ (isrc, h, f, p);
}

::std::auto_ptr< ::MasterSlaveBinding >
MasterSlaveBinding_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MasterSlaveBinding_ (isrc, f, p);
}

::std::auto_ptr< ::MasterSlaveBinding >
MasterSlaveBinding_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MasterSlaveBinding_ (isrc, h, f, p);
}

::std::auto_ptr< ::MasterSlaveBinding >
MasterSlaveBinding_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MasterSlaveBinding_ (isrc, h, f, p);
}

::std::auto_ptr< ::MasterSlaveBinding >
MasterSlaveBinding_ (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::MasterSlaveBinding > (
    ::MasterSlaveBinding_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterSlaveBinding >
MasterSlaveBinding_ (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MasterSlaveBinding > (
    ::MasterSlaveBinding_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterSlaveBinding >
MasterSlaveBinding_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MasterSlaveBinding > (
    ::MasterSlaveBinding_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterSlaveBinding >
MasterSlaveBinding_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::MasterSlaveBinding > (
      ::MasterSlaveBinding_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "MasterSlaveBinding" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::MasterSlaveBinding > r (
      ::xsd::cxx::tree::traits< ::MasterSlaveBinding, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MasterSlaveBinding",
    "");
}

::std::auto_ptr< ::MasterSlaveBinding >
MasterSlaveBinding_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "MasterSlaveBinding" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::MasterSlaveBinding > r (
      ::xsd::cxx::tree::traits< ::MasterSlaveBinding, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MasterSlaveBinding",
    "");
}

::std::auto_ptr< ::CommunicationSet >
CommunicationSet_ (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::CommunicationSet > (
    ::CommunicationSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CommunicationSet >
CommunicationSet_ (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CommunicationSet > (
    ::CommunicationSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CommunicationSet >
CommunicationSet_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CommunicationSet > (
    ::CommunicationSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CommunicationSet >
CommunicationSet_ (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CommunicationSet_ (isrc, f, p);
}

::std::auto_ptr< ::CommunicationSet >
CommunicationSet_ (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CommunicationSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::CommunicationSet >
CommunicationSet_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CommunicationSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::CommunicationSet >
CommunicationSet_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CommunicationSet_ (isrc, f, p);
}

::std::auto_ptr< ::CommunicationSet >
CommunicationSet_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CommunicationSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::CommunicationSet >
CommunicationSet_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CommunicationSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::CommunicationSet >
CommunicationSet_ (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::CommunicationSet > (
    ::CommunicationSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CommunicationSet >
CommunicationSet_ (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CommunicationSet > (
    ::CommunicationSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CommunicationSet >
CommunicationSet_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CommunicationSet > (
    ::CommunicationSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CommunicationSet >
CommunicationSet_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::CommunicationSet > (
      ::CommunicationSet_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "CommunicationSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::CommunicationSet > r (
      ::xsd::cxx::tree::traits< ::CommunicationSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "CommunicationSet",
    "");
}

::std::auto_ptr< ::CommunicationSet >
CommunicationSet_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "CommunicationSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::CommunicationSet > r (
      ::xsd::cxx::tree::traits< ::CommunicationSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "CommunicationSet",
    "");
}

::std::auto_ptr< ::AbstractCommunication >
AbstractCommunication_ (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::AbstractCommunication > (
    ::AbstractCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AbstractCommunication >
AbstractCommunication_ (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AbstractCommunication > (
    ::AbstractCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AbstractCommunication >
AbstractCommunication_ (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AbstractCommunication > (
    ::AbstractCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AbstractCommunication >
AbstractCommunication_ (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AbstractCommunication_ (isrc, f, p);
}

::std::auto_ptr< ::AbstractCommunication >
AbstractCommunication_ (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AbstractCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::AbstractCommunication >
AbstractCommunication_ (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AbstractCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::AbstractCommunication >
AbstractCommunication_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AbstractCommunication_ (isrc, f, p);
}

::std::auto_ptr< ::AbstractCommunication >
AbstractCommunication_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AbstractCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::AbstractCommunication >
AbstractCommunication_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AbstractCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::AbstractCommunication >
AbstractCommunication_ (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::AbstractCommunication > (
    ::AbstractCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AbstractCommunication >
AbstractCommunication_ (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AbstractCommunication > (
    ::AbstractCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AbstractCommunication >
AbstractCommunication_ (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AbstractCommunication > (
    ::AbstractCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AbstractCommunication >
AbstractCommunication_ (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::AbstractCommunication > (
      ::AbstractCommunication_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "AbstractCommunication" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::AbstractCommunication > r (
      ::xsd::cxx::tree::traits< ::AbstractCommunication, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "AbstractCommunication",
    "");
}

::std::auto_ptr< ::AbstractCommunication >
AbstractCommunication_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "AbstractCommunication" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::AbstractCommunication > r (
      ::xsd::cxx::tree::traits< ::AbstractCommunication, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "AbstractCommunication",
    "");
}

::std::auto_ptr< ::Connection >
Connection_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::Connection > (
    ::Connection_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Connection >
Connection_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Connection > (
    ::Connection_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Connection >
Connection_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Connection > (
    ::Connection_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Connection >
Connection_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Connection_ (isrc, f, p);
}

::std::auto_ptr< ::Connection >
Connection_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Connection_ (isrc, h, f, p);
}

::std::auto_ptr< ::Connection >
Connection_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Connection_ (isrc, h, f, p);
}

::std::auto_ptr< ::Connection >
Connection_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Connection_ (isrc, f, p);
}

::std::auto_ptr< ::Connection >
Connection_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Connection_ (isrc, h, f, p);
}

::std::auto_ptr< ::Connection >
Connection_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Connection_ (isrc, h, f, p);
}

::std::auto_ptr< ::Connection >
Connection_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::Connection > (
    ::Connection_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Connection >
Connection_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Connection > (
    ::Connection_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Connection >
Connection_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Connection > (
    ::Connection_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Connection >
Connection_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::Connection > (
      ::Connection_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Connection" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Connection > r (
      ::xsd::cxx::tree::traits< ::Connection, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Connection",
    "");
}

::std::auto_ptr< ::Connection >
Connection_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Connection" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Connection > r (
      ::xsd::cxx::tree::traits< ::Connection, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Connection",
    "");
}

::std::auto_ptr< ::PerformanceSet >
PerformanceSet_ (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::PerformanceSet > (
    ::PerformanceSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::PerformanceSet >
PerformanceSet_ (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::PerformanceSet > (
    ::PerformanceSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::PerformanceSet >
PerformanceSet_ (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::PerformanceSet > (
    ::PerformanceSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::PerformanceSet >
PerformanceSet_ (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::PerformanceSet_ (isrc, f, p);
}

::std::auto_ptr< ::PerformanceSet >
PerformanceSet_ (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::PerformanceSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::PerformanceSet >
PerformanceSet_ (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::PerformanceSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::PerformanceSet >
PerformanceSet_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::PerformanceSet_ (isrc, f, p);
}

::std::auto_ptr< ::PerformanceSet >
PerformanceSet_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::PerformanceSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::PerformanceSet >
PerformanceSet_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::PerformanceSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::PerformanceSet >
PerformanceSet_ (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::PerformanceSet > (
    ::PerformanceSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::PerformanceSet >
PerformanceSet_ (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::PerformanceSet > (
    ::PerformanceSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::PerformanceSet >
PerformanceSet_ (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::PerformanceSet > (
    ::PerformanceSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::PerformanceSet >
PerformanceSet_ (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::PerformanceSet > (
      ::PerformanceSet_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "PerformanceSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::PerformanceSet > r (
      ::xsd::cxx::tree::traits< ::PerformanceSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "PerformanceSet",
    "");
}

::std::auto_ptr< ::PerformanceSet >
PerformanceSet_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "PerformanceSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::PerformanceSet > r (
      ::xsd::cxx::tree::traits< ::PerformanceSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "PerformanceSet",
    "");
}

::std::auto_ptr< ::FIFOCommunication >
FIFOCommunication_ (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::FIFOCommunication > (
    ::FIFOCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::FIFOCommunication >
FIFOCommunication_ (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::FIFOCommunication > (
    ::FIFOCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::FIFOCommunication >
FIFOCommunication_ (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::FIFOCommunication > (
    ::FIFOCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::FIFOCommunication >
FIFOCommunication_ (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::FIFOCommunication_ (isrc, f, p);
}

::std::auto_ptr< ::FIFOCommunication >
FIFOCommunication_ (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::FIFOCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::FIFOCommunication >
FIFOCommunication_ (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::FIFOCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::FIFOCommunication >
FIFOCommunication_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::FIFOCommunication_ (isrc, f, p);
}

::std::auto_ptr< ::FIFOCommunication >
FIFOCommunication_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::FIFOCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::FIFOCommunication >
FIFOCommunication_ (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::FIFOCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::FIFOCommunication >
FIFOCommunication_ (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::FIFOCommunication > (
    ::FIFOCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::FIFOCommunication >
FIFOCommunication_ (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::FIFOCommunication > (
    ::FIFOCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::FIFOCommunication >
FIFOCommunication_ (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::FIFOCommunication > (
    ::FIFOCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::FIFOCommunication >
FIFOCommunication_ (const ::xercesc::DOMDocument& doc,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::FIFOCommunication > (
      ::FIFOCommunication_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "FIFOCommunication" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::FIFOCommunication > r (
      ::xsd::cxx::tree::traits< ::FIFOCommunication, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "FIFOCommunication",
    "");
}

::std::auto_ptr< ::FIFOCommunication >
FIFOCommunication_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "FIFOCommunication" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::FIFOCommunication > r (
      ::xsd::cxx::tree::traits< ::FIFOCommunication, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "FIFOCommunication",
    "");
}

::std::auto_ptr< ::CommonInstructionSet >
CommonInstructionSet_ (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::CommonInstructionSet > (
    ::CommonInstructionSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CommonInstructionSet >
CommonInstructionSet_ (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CommonInstructionSet > (
    ::CommonInstructionSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CommonInstructionSet >
CommonInstructionSet_ (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CommonInstructionSet > (
    ::CommonInstructionSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CommonInstructionSet >
CommonInstructionSet_ (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CommonInstructionSet_ (isrc, f, p);
}

::std::auto_ptr< ::CommonInstructionSet >
CommonInstructionSet_ (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CommonInstructionSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::CommonInstructionSet >
CommonInstructionSet_ (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CommonInstructionSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::CommonInstructionSet >
CommonInstructionSet_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CommonInstructionSet_ (isrc, f, p);
}

::std::auto_ptr< ::CommonInstructionSet >
CommonInstructionSet_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CommonInstructionSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::CommonInstructionSet >
CommonInstructionSet_ (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CommonInstructionSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::CommonInstructionSet >
CommonInstructionSet_ (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::CommonInstructionSet > (
    ::CommonInstructionSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CommonInstructionSet >
CommonInstructionSet_ (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CommonInstructionSet > (
    ::CommonInstructionSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CommonInstructionSet >
CommonInstructionSet_ (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CommonInstructionSet > (
    ::CommonInstructionSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CommonInstructionSet >
CommonInstructionSet_ (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::CommonInstructionSet > (
      ::CommonInstructionSet_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "CommonInstructionSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::CommonInstructionSet > r (
      ::xsd::cxx::tree::traits< ::CommonInstructionSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "CommonInstructionSet",
    "");
}

::std::auto_ptr< ::CommonInstructionSet >
CommonInstructionSet_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "CommonInstructionSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::CommonInstructionSet > r (
      ::xsd::cxx::tree::traits< ::CommonInstructionSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "CommonInstructionSet",
    "");
}

::std::auto_ptr< ::Cache >
Cache_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::Cache > (
    ::Cache_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Cache >
Cache_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Cache > (
    ::Cache_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Cache >
Cache_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Cache > (
    ::Cache_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Cache >
Cache_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Cache_ (isrc, f, p);
}

::std::auto_ptr< ::Cache >
Cache_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Cache_ (isrc, h, f, p);
}

::std::auto_ptr< ::Cache >
Cache_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Cache_ (isrc, h, f, p);
}

::std::auto_ptr< ::Cache >
Cache_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Cache_ (isrc, f, p);
}

::std::auto_ptr< ::Cache >
Cache_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Cache_ (isrc, h, f, p);
}

::std::auto_ptr< ::Cache >
Cache_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Cache_ (isrc, h, f, p);
}

::std::auto_ptr< ::Cache >
Cache_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::Cache > (
    ::Cache_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Cache >
Cache_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Cache > (
    ::Cache_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Cache >
Cache_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Cache > (
    ::Cache_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Cache >
Cache_ (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::Cache > (
      ::Cache_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Cache" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Cache > r (
      ::xsd::cxx::tree::traits< ::Cache, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Cache",
    "");
}

::std::auto_ptr< ::Cache >
Cache_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Cache" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Cache > r (
      ::xsd::cxx::tree::traits< ::Cache, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Cache",
    "");
}

::std::auto_ptr< ::SystemConfiguration >
SystemConfiguration_ (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::SystemConfiguration > (
    ::SystemConfiguration_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SystemConfiguration >
SystemConfiguration_ (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SystemConfiguration > (
    ::SystemConfiguration_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SystemConfiguration >
SystemConfiguration_ (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SystemConfiguration > (
    ::SystemConfiguration_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SystemConfiguration >
SystemConfiguration_ (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SystemConfiguration_ (isrc, f, p);
}

::std::auto_ptr< ::SystemConfiguration >
SystemConfiguration_ (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SystemConfiguration_ (isrc, h, f, p);
}

::std::auto_ptr< ::SystemConfiguration >
SystemConfiguration_ (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SystemConfiguration_ (isrc, h, f, p);
}

::std::auto_ptr< ::SystemConfiguration >
SystemConfiguration_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SystemConfiguration_ (isrc, f, p);
}

::std::auto_ptr< ::SystemConfiguration >
SystemConfiguration_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SystemConfiguration_ (isrc, h, f, p);
}

::std::auto_ptr< ::SystemConfiguration >
SystemConfiguration_ (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SystemConfiguration_ (isrc, h, f, p);
}

::std::auto_ptr< ::SystemConfiguration >
SystemConfiguration_ (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::SystemConfiguration > (
    ::SystemConfiguration_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SystemConfiguration >
SystemConfiguration_ (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SystemConfiguration > (
    ::SystemConfiguration_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SystemConfiguration >
SystemConfiguration_ (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SystemConfiguration > (
    ::SystemConfiguration_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SystemConfiguration >
SystemConfiguration_ (const ::xercesc::DOMDocument& doc,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::SystemConfiguration > (
      ::SystemConfiguration_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "SystemConfiguration" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SystemConfiguration > r (
      ::xsd::cxx::tree::traits< ::SystemConfiguration, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "SystemConfiguration",
    "");
}

::std::auto_ptr< ::SystemConfiguration >
SystemConfiguration_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "SystemConfiguration" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SystemConfiguration > r (
      ::xsd::cxx::tree::traits< ::SystemConfiguration, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "SystemConfiguration",
    "");
}

::std::auto_ptr< ::ConnectionSet >
ConnectionSet_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::ConnectionSet > (
    ::ConnectionSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ConnectionSet >
ConnectionSet_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ConnectionSet > (
    ::ConnectionSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ConnectionSet >
ConnectionSet_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ConnectionSet > (
    ::ConnectionSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ConnectionSet >
ConnectionSet_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ConnectionSet_ (isrc, f, p);
}

::std::auto_ptr< ::ConnectionSet >
ConnectionSet_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ConnectionSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::ConnectionSet >
ConnectionSet_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ConnectionSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::ConnectionSet >
ConnectionSet_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ConnectionSet_ (isrc, f, p);
}

::std::auto_ptr< ::ConnectionSet >
ConnectionSet_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ConnectionSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::ConnectionSet >
ConnectionSet_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ConnectionSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::ConnectionSet >
ConnectionSet_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::ConnectionSet > (
    ::ConnectionSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ConnectionSet >
ConnectionSet_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ConnectionSet > (
    ::ConnectionSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ConnectionSet >
ConnectionSet_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ConnectionSet > (
    ::ConnectionSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ConnectionSet >
ConnectionSet_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::ConnectionSet > (
      ::ConnectionSet_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "ConnectionSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::ConnectionSet > r (
      ::xsd::cxx::tree::traits< ::ConnectionSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "ConnectionSet",
    "");
}

::std::auto_ptr< ::ConnectionSet >
ConnectionSet_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "ConnectionSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::ConnectionSet > r (
      ::xsd::cxx::tree::traits< ::ConnectionSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "ConnectionSet",
    "");
}

::std::auto_ptr< ::MemoryConsistencyModel >
MemoryConsistencyModel_ (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::MemoryConsistencyModel > (
    ::MemoryConsistencyModel_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MemoryConsistencyModel >
MemoryConsistencyModel_ (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MemoryConsistencyModel > (
    ::MemoryConsistencyModel_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MemoryConsistencyModel >
MemoryConsistencyModel_ (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MemoryConsistencyModel > (
    ::MemoryConsistencyModel_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MemoryConsistencyModel >
MemoryConsistencyModel_ (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MemoryConsistencyModel_ (isrc, f, p);
}

::std::auto_ptr< ::MemoryConsistencyModel >
MemoryConsistencyModel_ (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MemoryConsistencyModel_ (isrc, h, f, p);
}

::std::auto_ptr< ::MemoryConsistencyModel >
MemoryConsistencyModel_ (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MemoryConsistencyModel_ (isrc, h, f, p);
}

::std::auto_ptr< ::MemoryConsistencyModel >
MemoryConsistencyModel_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MemoryConsistencyModel_ (isrc, f, p);
}

::std::auto_ptr< ::MemoryConsistencyModel >
MemoryConsistencyModel_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MemoryConsistencyModel_ (isrc, h, f, p);
}

::std::auto_ptr< ::MemoryConsistencyModel >
MemoryConsistencyModel_ (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MemoryConsistencyModel_ (isrc, h, f, p);
}

::std::auto_ptr< ::MemoryConsistencyModel >
MemoryConsistencyModel_ (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::MemoryConsistencyModel > (
    ::MemoryConsistencyModel_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MemoryConsistencyModel >
MemoryConsistencyModel_ (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MemoryConsistencyModel > (
    ::MemoryConsistencyModel_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MemoryConsistencyModel >
MemoryConsistencyModel_ (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MemoryConsistencyModel > (
    ::MemoryConsistencyModel_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MemoryConsistencyModel >
MemoryConsistencyModel_ (const ::xercesc::DOMDocument& doc,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::MemoryConsistencyModel > (
      ::MemoryConsistencyModel_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "MemoryConsistencyModel" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::MemoryConsistencyModel > r (
      ::xsd::cxx::tree::traits< ::MemoryConsistencyModel, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MemoryConsistencyModel",
    "");
}

::std::auto_ptr< ::MemoryConsistencyModel >
MemoryConsistencyModel_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "MemoryConsistencyModel" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::MemoryConsistencyModel > r (
      ::xsd::cxx::tree::traits< ::MemoryConsistencyModel, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MemoryConsistencyModel",
    "");
}

::std::auto_ptr< ::SharedRegisterCommunication >
SharedRegisterCommunication_ (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::SharedRegisterCommunication > (
    ::SharedRegisterCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SharedRegisterCommunication >
SharedRegisterCommunication_ (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SharedRegisterCommunication > (
    ::SharedRegisterCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SharedRegisterCommunication >
SharedRegisterCommunication_ (const ::std::string& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SharedRegisterCommunication > (
    ::SharedRegisterCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SharedRegisterCommunication >
SharedRegisterCommunication_ (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SharedRegisterCommunication_ (isrc, f, p);
}

::std::auto_ptr< ::SharedRegisterCommunication >
SharedRegisterCommunication_ (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SharedRegisterCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::SharedRegisterCommunication >
SharedRegisterCommunication_ (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SharedRegisterCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::SharedRegisterCommunication >
SharedRegisterCommunication_ (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SharedRegisterCommunication_ (isrc, f, p);
}

::std::auto_ptr< ::SharedRegisterCommunication >
SharedRegisterCommunication_ (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SharedRegisterCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::SharedRegisterCommunication >
SharedRegisterCommunication_ (::std::istream& is,
                              const ::std::string& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SharedRegisterCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::SharedRegisterCommunication >
SharedRegisterCommunication_ (::xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::SharedRegisterCommunication > (
    ::SharedRegisterCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SharedRegisterCommunication >
SharedRegisterCommunication_ (::xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SharedRegisterCommunication > (
    ::SharedRegisterCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SharedRegisterCommunication >
SharedRegisterCommunication_ (::xercesc::InputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SharedRegisterCommunication > (
    ::SharedRegisterCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SharedRegisterCommunication >
SharedRegisterCommunication_ (const ::xercesc::DOMDocument& doc,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::SharedRegisterCommunication > (
      ::SharedRegisterCommunication_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "SharedRegisterCommunication" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SharedRegisterCommunication > r (
      ::xsd::cxx::tree::traits< ::SharedRegisterCommunication, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "SharedRegisterCommunication",
    "");
}

::std::auto_ptr< ::SharedRegisterCommunication >
SharedRegisterCommunication_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "SharedRegisterCommunication" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SharedRegisterCommunication > r (
      ::xsd::cxx::tree::traits< ::SharedRegisterCommunication, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "SharedRegisterCommunication",
    "");
}

::std::auto_ptr< ::SharedMemoryCommunication >
SharedMemoryCommunication_ (const ::std::string& u,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::SharedMemoryCommunication > (
    ::SharedMemoryCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SharedMemoryCommunication >
SharedMemoryCommunication_ (const ::std::string& u,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SharedMemoryCommunication > (
    ::SharedMemoryCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SharedMemoryCommunication >
SharedMemoryCommunication_ (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SharedMemoryCommunication > (
    ::SharedMemoryCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SharedMemoryCommunication >
SharedMemoryCommunication_ (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SharedMemoryCommunication_ (isrc, f, p);
}

::std::auto_ptr< ::SharedMemoryCommunication >
SharedMemoryCommunication_ (::std::istream& is,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SharedMemoryCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::SharedMemoryCommunication >
SharedMemoryCommunication_ (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::SharedMemoryCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::SharedMemoryCommunication >
SharedMemoryCommunication_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SharedMemoryCommunication_ (isrc, f, p);
}

::std::auto_ptr< ::SharedMemoryCommunication >
SharedMemoryCommunication_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SharedMemoryCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::SharedMemoryCommunication >
SharedMemoryCommunication_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::SharedMemoryCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::SharedMemoryCommunication >
SharedMemoryCommunication_ (::xercesc::InputSource& i,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::SharedMemoryCommunication > (
    ::SharedMemoryCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SharedMemoryCommunication >
SharedMemoryCommunication_ (::xercesc::InputSource& i,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SharedMemoryCommunication > (
    ::SharedMemoryCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SharedMemoryCommunication >
SharedMemoryCommunication_ (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::SharedMemoryCommunication > (
    ::SharedMemoryCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::SharedMemoryCommunication >
SharedMemoryCommunication_ (const ::xercesc::DOMDocument& doc,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::SharedMemoryCommunication > (
      ::SharedMemoryCommunication_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "SharedMemoryCommunication" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SharedMemoryCommunication > r (
      ::xsd::cxx::tree::traits< ::SharedMemoryCommunication, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "SharedMemoryCommunication",
    "");
}

::std::auto_ptr< ::SharedMemoryCommunication >
SharedMemoryCommunication_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "SharedMemoryCommunication" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::SharedMemoryCommunication > r (
      ::xsd::cxx::tree::traits< ::SharedMemoryCommunication, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "SharedMemoryCommunication",
    "");
}

::std::auto_ptr< ::EventCommunication >
EventCommunication_ (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::EventCommunication > (
    ::EventCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::EventCommunication >
EventCommunication_ (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::EventCommunication > (
    ::EventCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::EventCommunication >
EventCommunication_ (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::EventCommunication > (
    ::EventCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::EventCommunication >
EventCommunication_ (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::EventCommunication_ (isrc, f, p);
}

::std::auto_ptr< ::EventCommunication >
EventCommunication_ (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::EventCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::EventCommunication >
EventCommunication_ (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::EventCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::EventCommunication >
EventCommunication_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::EventCommunication_ (isrc, f, p);
}

::std::auto_ptr< ::EventCommunication >
EventCommunication_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::EventCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::EventCommunication >
EventCommunication_ (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::EventCommunication_ (isrc, h, f, p);
}

::std::auto_ptr< ::EventCommunication >
EventCommunication_ (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::EventCommunication > (
    ::EventCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::EventCommunication >
EventCommunication_ (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::EventCommunication > (
    ::EventCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::EventCommunication >
EventCommunication_ (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::EventCommunication > (
    ::EventCommunication_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::EventCommunication >
EventCommunication_ (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::EventCommunication > (
      ::EventCommunication_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "EventCommunication" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::EventCommunication > r (
      ::xsd::cxx::tree::traits< ::EventCommunication, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "EventCommunication",
    "");
}

::std::auto_ptr< ::EventCommunication >
EventCommunication_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "EventCommunication" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::EventCommunication > r (
      ::xsd::cxx::tree::traits< ::EventCommunication, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "EventCommunication",
    "");
}

::std::auto_ptr< ::ClockFrequency >
ClockFrequency_ (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::ClockFrequency > (
    ::ClockFrequency_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ClockFrequency >
ClockFrequency_ (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ClockFrequency > (
    ::ClockFrequency_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ClockFrequency >
ClockFrequency_ (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ClockFrequency > (
    ::ClockFrequency_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ClockFrequency >
ClockFrequency_ (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ClockFrequency_ (isrc, f, p);
}

::std::auto_ptr< ::ClockFrequency >
ClockFrequency_ (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ClockFrequency_ (isrc, h, f, p);
}

::std::auto_ptr< ::ClockFrequency >
ClockFrequency_ (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ClockFrequency_ (isrc, h, f, p);
}

::std::auto_ptr< ::ClockFrequency >
ClockFrequency_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ClockFrequency_ (isrc, f, p);
}

::std::auto_ptr< ::ClockFrequency >
ClockFrequency_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ClockFrequency_ (isrc, h, f, p);
}

::std::auto_ptr< ::ClockFrequency >
ClockFrequency_ (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ClockFrequency_ (isrc, h, f, p);
}

::std::auto_ptr< ::ClockFrequency >
ClockFrequency_ (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::ClockFrequency > (
    ::ClockFrequency_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ClockFrequency >
ClockFrequency_ (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ClockFrequency > (
    ::ClockFrequency_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ClockFrequency >
ClockFrequency_ (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ClockFrequency > (
    ::ClockFrequency_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ClockFrequency >
ClockFrequency_ (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::ClockFrequency > (
      ::ClockFrequency_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "ClockFrequency" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::ClockFrequency > r (
      ::xsd::cxx::tree::traits< ::ClockFrequency, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "ClockFrequency",
    "");
}

::std::auto_ptr< ::ClockFrequency >
ClockFrequency_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "ClockFrequency" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::ClockFrequency > r (
      ::xsd::cxx::tree::traits< ::ClockFrequency, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "ClockFrequency",
    "");
}

::std::auto_ptr< ::Accessor >
Accessor_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::Accessor > (
    ::Accessor_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Accessor >
Accessor_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Accessor > (
    ::Accessor_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Accessor >
Accessor_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Accessor > (
    ::Accessor_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Accessor >
Accessor_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Accessor_ (isrc, f, p);
}

::std::auto_ptr< ::Accessor >
Accessor_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Accessor_ (isrc, h, f, p);
}

::std::auto_ptr< ::Accessor >
Accessor_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Accessor_ (isrc, h, f, p);
}

::std::auto_ptr< ::Accessor >
Accessor_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Accessor_ (isrc, f, p);
}

::std::auto_ptr< ::Accessor >
Accessor_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Accessor_ (isrc, h, f, p);
}

::std::auto_ptr< ::Accessor >
Accessor_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Accessor_ (isrc, h, f, p);
}

::std::auto_ptr< ::Accessor >
Accessor_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::Accessor > (
    ::Accessor_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Accessor >
Accessor_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Accessor > (
    ::Accessor_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Accessor >
Accessor_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Accessor > (
    ::Accessor_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Accessor >
Accessor_ (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::Accessor > (
      ::Accessor_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Accessor" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Accessor > r (
      ::xsd::cxx::tree::traits< ::Accessor, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Accessor",
    "");
}

::std::auto_ptr< ::Accessor >
Accessor_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Accessor" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Accessor > r (
      ::xsd::cxx::tree::traits< ::Accessor, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Accessor",
    "");
}

::std::auto_ptr< ::AccessType >
AccessType_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::AccessType > (
    ::AccessType_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AccessType >
AccessType_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AccessType > (
    ::AccessType_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AccessType >
AccessType_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AccessType > (
    ::AccessType_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AccessType >
AccessType_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AccessType_ (isrc, f, p);
}

::std::auto_ptr< ::AccessType >
AccessType_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AccessType_ (isrc, h, f, p);
}

::std::auto_ptr< ::AccessType >
AccessType_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AccessType_ (isrc, h, f, p);
}

::std::auto_ptr< ::AccessType >
AccessType_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AccessType_ (isrc, f, p);
}

::std::auto_ptr< ::AccessType >
AccessType_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AccessType_ (isrc, h, f, p);
}

::std::auto_ptr< ::AccessType >
AccessType_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AccessType_ (isrc, h, f, p);
}

::std::auto_ptr< ::AccessType >
AccessType_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::AccessType > (
    ::AccessType_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AccessType >
AccessType_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AccessType > (
    ::AccessType_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AccessType >
AccessType_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AccessType > (
    ::AccessType_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AccessType >
AccessType_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::AccessType > (
      ::AccessType_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "AccessType" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::AccessType > r (
      ::xsd::cxx::tree::traits< ::AccessType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "AccessType",
    "");
}

::std::auto_ptr< ::AccessType >
AccessType_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "AccessType" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::AccessType > r (
      ::xsd::cxx::tree::traits< ::AccessType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "AccessType",
    "");
}

::std::auto_ptr< ::MasterSlaveBindingSet >
MasterSlaveBindingSet_ (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::MasterSlaveBindingSet > (
    ::MasterSlaveBindingSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterSlaveBindingSet >
MasterSlaveBindingSet_ (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MasterSlaveBindingSet > (
    ::MasterSlaveBindingSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterSlaveBindingSet >
MasterSlaveBindingSet_ (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MasterSlaveBindingSet > (
    ::MasterSlaveBindingSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterSlaveBindingSet >
MasterSlaveBindingSet_ (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MasterSlaveBindingSet_ (isrc, f, p);
}

::std::auto_ptr< ::MasterSlaveBindingSet >
MasterSlaveBindingSet_ (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MasterSlaveBindingSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::MasterSlaveBindingSet >
MasterSlaveBindingSet_ (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MasterSlaveBindingSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::MasterSlaveBindingSet >
MasterSlaveBindingSet_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MasterSlaveBindingSet_ (isrc, f, p);
}

::std::auto_ptr< ::MasterSlaveBindingSet >
MasterSlaveBindingSet_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MasterSlaveBindingSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::MasterSlaveBindingSet >
MasterSlaveBindingSet_ (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MasterSlaveBindingSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::MasterSlaveBindingSet >
MasterSlaveBindingSet_ (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::MasterSlaveBindingSet > (
    ::MasterSlaveBindingSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterSlaveBindingSet >
MasterSlaveBindingSet_ (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MasterSlaveBindingSet > (
    ::MasterSlaveBindingSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterSlaveBindingSet >
MasterSlaveBindingSet_ (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MasterSlaveBindingSet > (
    ::MasterSlaveBindingSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MasterSlaveBindingSet >
MasterSlaveBindingSet_ (const ::xercesc::DOMDocument& doc,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::MasterSlaveBindingSet > (
      ::MasterSlaveBindingSet_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "MasterSlaveBindingSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::MasterSlaveBindingSet > r (
      ::xsd::cxx::tree::traits< ::MasterSlaveBindingSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MasterSlaveBindingSet",
    "");
}

::std::auto_ptr< ::MasterSlaveBindingSet >
MasterSlaveBindingSet_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "MasterSlaveBindingSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::MasterSlaveBindingSet > r (
      ::xsd::cxx::tree::traits< ::MasterSlaveBindingSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MasterSlaveBindingSet",
    "");
}

::std::auto_ptr< ::Performance >
Performance_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::Performance > (
    ::Performance_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Performance >
Performance_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Performance > (
    ::Performance_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Performance >
Performance_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Performance > (
    ::Performance_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Performance >
Performance_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Performance_ (isrc, f, p);
}

::std::auto_ptr< ::Performance >
Performance_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Performance_ (isrc, h, f, p);
}

::std::auto_ptr< ::Performance >
Performance_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Performance_ (isrc, h, f, p);
}

::std::auto_ptr< ::Performance >
Performance_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Performance_ (isrc, f, p);
}

::std::auto_ptr< ::Performance >
Performance_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Performance_ (isrc, h, f, p);
}

::std::auto_ptr< ::Performance >
Performance_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Performance_ (isrc, h, f, p);
}

::std::auto_ptr< ::Performance >
Performance_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::Performance > (
    ::Performance_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Performance >
Performance_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Performance > (
    ::Performance_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Performance >
Performance_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::Performance > (
    ::Performance_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::Performance >
Performance_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::Performance > (
      ::Performance_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Performance" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Performance > r (
      ::xsd::cxx::tree::traits< ::Performance, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Performance",
    "");
}

::std::auto_ptr< ::Performance >
Performance_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Performance" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Performance > r (
      ::xsd::cxx::tree::traits< ::Performance, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Performance",
    "");
}

::std::auto_ptr< ::AccessTypeSet >
AccessTypeSet_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::AccessTypeSet > (
    ::AccessTypeSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AccessTypeSet >
AccessTypeSet_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AccessTypeSet > (
    ::AccessTypeSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AccessTypeSet >
AccessTypeSet_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AccessTypeSet > (
    ::AccessTypeSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AccessTypeSet >
AccessTypeSet_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AccessTypeSet_ (isrc, f, p);
}

::std::auto_ptr< ::AccessTypeSet >
AccessTypeSet_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AccessTypeSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::AccessTypeSet >
AccessTypeSet_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::AccessTypeSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::AccessTypeSet >
AccessTypeSet_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AccessTypeSet_ (isrc, f, p);
}

::std::auto_ptr< ::AccessTypeSet >
AccessTypeSet_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AccessTypeSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::AccessTypeSet >
AccessTypeSet_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::AccessTypeSet_ (isrc, h, f, p);
}

::std::auto_ptr< ::AccessTypeSet >
AccessTypeSet_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::AccessTypeSet > (
    ::AccessTypeSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AccessTypeSet >
AccessTypeSet_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AccessTypeSet > (
    ::AccessTypeSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AccessTypeSet >
AccessTypeSet_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::AccessTypeSet > (
    ::AccessTypeSet_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::AccessTypeSet >
AccessTypeSet_ (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::AccessTypeSet > (
      ::AccessTypeSet_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "AccessTypeSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::AccessTypeSet > r (
      ::xsd::cxx::tree::traits< ::AccessTypeSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "AccessTypeSet",
    "");
}

::std::auto_ptr< ::AccessTypeSet >
AccessTypeSet_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "AccessTypeSet" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::AccessTypeSet > r (
      ::xsd::cxx::tree::traits< ::AccessTypeSet, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "AccessTypeSet",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

